/*
Beyond Networking Service(BNS) Load Balancer API

BNS Load Balancer API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package loadbalancer

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type LoadBalancerL7PoliciesAPI interface {

	/*
		AddL7PolicyRule Add L7 policy rule

		로드 밸런서의 지정한 L7 정책에 규칙을 추가합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param l7PolicyId 규칙을 추가할 대상 L7 정책 ID
		@return ApiAddL7PolicyRuleRequest
	*/
	AddL7PolicyRule(ctx context.Context, l7PolicyId string) ApiAddL7PolicyRuleRequest

	// AddL7PolicyRuleExecute executes the request
	//  @return BnsLoadBalancerV1ApiAddL7PolicyRuleModelResponseL7PolicyRuleModel
	AddL7PolicyRuleExecute(r ApiAddL7PolicyRuleRequest) (*BnsLoadBalancerV1ApiAddL7PolicyRuleModelResponseL7PolicyRuleModel, *http.Response, error)

	/*
		CreateL7Policy Create L7 policy

		지정한 리스너에 L7 정책을 생성합니다.<br/>
	정책은 하나 이상의 L7 규칙과 함께 구성되어야 하며, 리디렉션 동작(action)에 따라 대상 그룹, 경로(prefix), URL 등을 지정할 수 있습니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateL7PolicyRequest
	*/
	CreateL7Policy(ctx context.Context) ApiCreateL7PolicyRequest

	// CreateL7PolicyExecute executes the request
	//  @return BnsLoadBalancerV1ApiCreateL7PolicyModelResponseL7PolicyModel
	CreateL7PolicyExecute(r ApiCreateL7PolicyRequest) (*BnsLoadBalancerV1ApiCreateL7PolicyModelResponseL7PolicyModel, *http.Response, error)

	/*
		DeleteL7Policy Delete L7 policy

		로드 밸런서에 설정된 특정 L7 정책(Policy)을 삭제합니다.
	삭제 시, 해당 정책에 포함된 모든 L7 규칙도 함께 제거됩니다.

	:::caution 주의
	- L7 정책을 삭제하면 트래픽 라우팅 규칙이 제거되어 서비스 흐름에 영향을 줄 수 있습니다.
	- 삭제 전 리스너에 설정된 기본 대상 그룹 및 기타 정책 구성을 반드시 확인하세요.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param l7PolicyId 삭제할 L7 정책의 ID
		@return ApiDeleteL7PolicyRequest
	*/
	DeleteL7Policy(ctx context.Context, l7PolicyId string) ApiDeleteL7PolicyRequest

	// DeleteL7PolicyExecute executes the request
	DeleteL7PolicyExecute(r ApiDeleteL7PolicyRequest) (*http.Response, error)

	/*
		DeleteL7PolicyRule Delete L7 policy rule

		로드 밸런서의 특정 L7 정책에 설정된 L7 규칙을 삭제합니다.

	:::caution 주의
	- L7 규칙이 삭제되면 해당 규칙에 따라 수행되던 트래픽 분기 또는 리디렉션 정책이 더 이상 적용되지 않습니다.
	- 정책 동작에 영향을 줄 수 있으므로 삭제 전에 전체 L7 정책 구성을 확인하세요.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param l7PolicyId 삭제할 L7 정책의 ID
		@param l7RuleId 삭제할 L7 규칙의 ID
		@return ApiDeleteL7PolicyRuleRequest
	*/
	DeleteL7PolicyRule(ctx context.Context, l7PolicyId string, l7RuleId string) ApiDeleteL7PolicyRuleRequest

	// DeleteL7PolicyRuleExecute executes the request
	DeleteL7PolicyRuleExecute(r ApiDeleteL7PolicyRuleRequest) (*http.Response, error)

	/*
		GetL7Policy Get L7 policy

		지정한 L7 정책 ID에 해당하는 L7 정책의 상세 정보를 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param l7PolicyId 조회할 L7 정책 ID
		@return ApiGetL7PolicyRequest
	*/
	GetL7Policy(ctx context.Context, l7PolicyId string) ApiGetL7PolicyRequest

	// GetL7PolicyExecute executes the request
	//  @return BnsLoadBalancerV1ApiGetL7PolicyModelResponseL7PolicyModel
	GetL7PolicyExecute(r ApiGetL7PolicyRequest) (*BnsLoadBalancerV1ApiGetL7PolicyModelResponseL7PolicyModel, *http.Response, error)

	/*
		GetL7PolicyRule Get L7 policy rule

		로드 밸런서의 특정 L7 정책(Policy)에 속한 단일 L7 규칙의 상세 정보를 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param l7PolicyId 조회할 L7 정책 ID
		@param l7RuleId 조회할 L7 규칙 ID
		@return ApiGetL7PolicyRuleRequest
	*/
	GetL7PolicyRule(ctx context.Context, l7PolicyId string, l7RuleId string) ApiGetL7PolicyRuleRequest

	// GetL7PolicyRuleExecute executes the request
	//  @return Responsel7PolicyRuleModel
	GetL7PolicyRuleExecute(r ApiGetL7PolicyRuleRequest) (*Responsel7PolicyRuleModel, *http.Response, error)

	/*
		ListL7Policies List L7 policies

		지정한 로드 밸런서와 리스너에 연결된 L7 정책 목록을 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param loadBalancerId 조회할 로드 밸런서 ID
		@param listenerId 조회할 리스너 ID
		@return ApiListL7PoliciesRequest
	*/
	ListL7Policies(ctx context.Context, loadBalancerId string, listenerId string) ApiListL7PoliciesRequest

	// ListL7PoliciesExecute executes the request
	//  @return L7PolicyListModel
	ListL7PoliciesExecute(r ApiListL7PoliciesRequest) (*L7PolicyListModel, *http.Response, error)

	/*
		ListL7PolicyRules List L7 policy rules

		지정한 L7 정책에 정의된 규칙 목록을 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param l7PolicyId 조회할 L7 정책 ID
		@return ApiListL7PolicyRulesRequest
	*/
	ListL7PolicyRules(ctx context.Context, l7PolicyId string) ApiListL7PolicyRulesRequest

	// ListL7PolicyRulesExecute executes the request
	//  @return L7PolicyRuleListModel
	ListL7PolicyRulesExecute(r ApiListL7PolicyRulesRequest) (*L7PolicyRuleListModel, *http.Response, error)

	/*
		UpdateL7Policy Update L7 policy

		지정한 L7 정책을 수정합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param l7PolicyId 수정할 대상 L7 정책의 ID
		@return ApiUpdateL7PolicyRequest
	*/
	UpdateL7Policy(ctx context.Context, l7PolicyId string) ApiUpdateL7PolicyRequest

	// UpdateL7PolicyExecute executes the request
	//  @return BnsLoadBalancerV1ApiUpdateL7PolicyModelResponseL7PolicyModel
	UpdateL7PolicyExecute(r ApiUpdateL7PolicyRequest) (*BnsLoadBalancerV1ApiUpdateL7PolicyModelResponseL7PolicyModel, *http.Response, error)

	/*
		UpdateL7PolicyRule Update L7 policy rule

		L7 정책에 속한 특정 L7 규칙의 조건 및 속성을 수정합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param l7PolicyId 수정할 L7 정책 ID
		@param l7RuleId 수정할 L7 규칙 ID
		@return ApiUpdateL7PolicyRuleRequest
	*/
	UpdateL7PolicyRule(ctx context.Context, l7PolicyId string, l7RuleId string) ApiUpdateL7PolicyRuleRequest

	// UpdateL7PolicyRuleExecute executes the request
	//  @return BnsLoadBalancerV1ApiUpdateL7PolicyRuleModelResponseL7PolicyRuleModel
	UpdateL7PolicyRuleExecute(r ApiUpdateL7PolicyRuleRequest) (*BnsLoadBalancerV1ApiUpdateL7PolicyRuleModelResponseL7PolicyRuleModel, *http.Response, error)
}

// LoadBalancerL7PoliciesAPIService LoadBalancerL7PoliciesAPI service
type LoadBalancerL7PoliciesAPIService service

type ApiAddL7PolicyRuleRequest struct {
	ctx                 context.Context
	ApiService          LoadBalancerL7PoliciesAPI
	l7PolicyId          string
	xAuthToken          *string
	bodyAddL7PolicyRule *BodyAddL7PolicyRule
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiAddL7PolicyRuleRequest) XAuthToken(xAuthToken string) ApiAddL7PolicyRuleRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiAddL7PolicyRuleRequest) BodyAddL7PolicyRule(bodyAddL7PolicyRule BodyAddL7PolicyRule) ApiAddL7PolicyRuleRequest {
	r.bodyAddL7PolicyRule = &bodyAddL7PolicyRule
	return r
}

func (r ApiAddL7PolicyRuleRequest) Execute() (*BnsLoadBalancerV1ApiAddL7PolicyRuleModelResponseL7PolicyRuleModel, *http.Response, error) {
	return r.ApiService.AddL7PolicyRuleExecute(r)
}

/*
AddL7PolicyRule Add L7 policy rule

로드 밸런서의 지정한 L7 정책에 규칙을 추가합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param l7PolicyId 규칙을 추가할 대상 L7 정책 ID
	@return ApiAddL7PolicyRuleRequest
*/
func (a *LoadBalancerL7PoliciesAPIService) AddL7PolicyRule(ctx context.Context, l7PolicyId string) ApiAddL7PolicyRuleRequest {
	return ApiAddL7PolicyRuleRequest{
		ApiService: a,
		ctx:        ctx,
		l7PolicyId: l7PolicyId,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiAddL7PolicyRuleModelResponseL7PolicyRuleModel
func (a *LoadBalancerL7PoliciesAPIService) AddL7PolicyRuleExecute(r ApiAddL7PolicyRuleRequest) (*BnsLoadBalancerV1ApiAddL7PolicyRuleModelResponseL7PolicyRuleModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiAddL7PolicyRuleModelResponseL7PolicyRuleModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerL7PoliciesAPIService.AddL7PolicyRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/l7policies/{l7_policy_id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"l7_policy_id"+"}", url.PathEscape(parameterValueToString(r.l7PolicyId, "l7PolicyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyAddL7PolicyRule == nil {
		return localVarReturnValue, nil, reportError("bodyAddL7PolicyRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyAddL7PolicyRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateL7PolicyRequest struct {
	ctx                context.Context
	ApiService         LoadBalancerL7PoliciesAPI
	xAuthToken         *string
	bodyCreateL7Policy *BodyCreateL7Policy
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiCreateL7PolicyRequest) XAuthToken(xAuthToken string) ApiCreateL7PolicyRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiCreateL7PolicyRequest) BodyCreateL7Policy(bodyCreateL7Policy BodyCreateL7Policy) ApiCreateL7PolicyRequest {
	r.bodyCreateL7Policy = &bodyCreateL7Policy
	return r
}

func (r ApiCreateL7PolicyRequest) Execute() (*BnsLoadBalancerV1ApiCreateL7PolicyModelResponseL7PolicyModel, *http.Response, error) {
	return r.ApiService.CreateL7PolicyExecute(r)
}

/*
CreateL7Policy Create L7 policy

지정한 리스너에 L7 정책을 생성합니다.<br/>
정책은 하나 이상의 L7 규칙과 함께 구성되어야 하며, 리디렉션 동작(action)에 따라 대상 그룹, 경로(prefix), URL 등을 지정할 수 있습니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateL7PolicyRequest
*/
func (a *LoadBalancerL7PoliciesAPIService) CreateL7Policy(ctx context.Context) ApiCreateL7PolicyRequest {
	return ApiCreateL7PolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiCreateL7PolicyModelResponseL7PolicyModel
func (a *LoadBalancerL7PoliciesAPIService) CreateL7PolicyExecute(r ApiCreateL7PolicyRequest) (*BnsLoadBalancerV1ApiCreateL7PolicyModelResponseL7PolicyModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiCreateL7PolicyModelResponseL7PolicyModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerL7PoliciesAPIService.CreateL7Policy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/l7policies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyCreateL7Policy == nil {
		return localVarReturnValue, nil, reportError("bodyCreateL7Policy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyCreateL7Policy
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteL7PolicyRequest struct {
	ctx        context.Context
	ApiService LoadBalancerL7PoliciesAPI
	l7PolicyId string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiDeleteL7PolicyRequest) XAuthToken(xAuthToken string) ApiDeleteL7PolicyRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiDeleteL7PolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteL7PolicyExecute(r)
}

/*
DeleteL7Policy Delete L7 policy

로드 밸런서에 설정된 특정 L7 정책(Policy)을 삭제합니다.
삭제 시, 해당 정책에 포함된 모든 L7 규칙도 함께 제거됩니다.

:::caution 주의
- L7 정책을 삭제하면 트래픽 라우팅 규칙이 제거되어 서비스 흐름에 영향을 줄 수 있습니다.
- 삭제 전 리스너에 설정된 기본 대상 그룹 및 기타 정책 구성을 반드시 확인하세요.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param l7PolicyId 삭제할 L7 정책의 ID
	@return ApiDeleteL7PolicyRequest
*/
func (a *LoadBalancerL7PoliciesAPIService) DeleteL7Policy(ctx context.Context, l7PolicyId string) ApiDeleteL7PolicyRequest {
	return ApiDeleteL7PolicyRequest{
		ApiService: a,
		ctx:        ctx,
		l7PolicyId: l7PolicyId,
	}
}

// Execute executes the request
func (a *LoadBalancerL7PoliciesAPIService) DeleteL7PolicyExecute(r ApiDeleteL7PolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerL7PoliciesAPIService.DeleteL7Policy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/l7policies/{l7_policy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"l7_policy_id"+"}", url.PathEscape(parameterValueToString(r.l7PolicyId, "l7PolicyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteL7PolicyRuleRequest struct {
	ctx        context.Context
	ApiService LoadBalancerL7PoliciesAPI
	l7PolicyId string
	l7RuleId   string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiDeleteL7PolicyRuleRequest) XAuthToken(xAuthToken string) ApiDeleteL7PolicyRuleRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiDeleteL7PolicyRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteL7PolicyRuleExecute(r)
}

/*
DeleteL7PolicyRule Delete L7 policy rule

로드 밸런서의 특정 L7 정책에 설정된 L7 규칙을 삭제합니다.

:::caution 주의
- L7 규칙이 삭제되면 해당 규칙에 따라 수행되던 트래픽 분기 또는 리디렉션 정책이 더 이상 적용되지 않습니다.
- 정책 동작에 영향을 줄 수 있으므로 삭제 전에 전체 L7 정책 구성을 확인하세요.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param l7PolicyId 삭제할 L7 정책의 ID
	@param l7RuleId 삭제할 L7 규칙의 ID
	@return ApiDeleteL7PolicyRuleRequest
*/
func (a *LoadBalancerL7PoliciesAPIService) DeleteL7PolicyRule(ctx context.Context, l7PolicyId string, l7RuleId string) ApiDeleteL7PolicyRuleRequest {
	return ApiDeleteL7PolicyRuleRequest{
		ApiService: a,
		ctx:        ctx,
		l7PolicyId: l7PolicyId,
		l7RuleId:   l7RuleId,
	}
}

// Execute executes the request
func (a *LoadBalancerL7PoliciesAPIService) DeleteL7PolicyRuleExecute(r ApiDeleteL7PolicyRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerL7PoliciesAPIService.DeleteL7PolicyRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/l7policies/{l7_policy_id}/rules/{l7_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"l7_policy_id"+"}", url.PathEscape(parameterValueToString(r.l7PolicyId, "l7PolicyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"l7_rule_id"+"}", url.PathEscape(parameterValueToString(r.l7RuleId, "l7RuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetL7PolicyRequest struct {
	ctx        context.Context
	ApiService LoadBalancerL7PoliciesAPI
	l7PolicyId string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiGetL7PolicyRequest) XAuthToken(xAuthToken string) ApiGetL7PolicyRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiGetL7PolicyRequest) Execute() (*BnsLoadBalancerV1ApiGetL7PolicyModelResponseL7PolicyModel, *http.Response, error) {
	return r.ApiService.GetL7PolicyExecute(r)
}

/*
GetL7Policy Get L7 policy

지정한 L7 정책 ID에 해당하는 L7 정책의 상세 정보를 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param l7PolicyId 조회할 L7 정책 ID
	@return ApiGetL7PolicyRequest
*/
func (a *LoadBalancerL7PoliciesAPIService) GetL7Policy(ctx context.Context, l7PolicyId string) ApiGetL7PolicyRequest {
	return ApiGetL7PolicyRequest{
		ApiService: a,
		ctx:        ctx,
		l7PolicyId: l7PolicyId,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiGetL7PolicyModelResponseL7PolicyModel
func (a *LoadBalancerL7PoliciesAPIService) GetL7PolicyExecute(r ApiGetL7PolicyRequest) (*BnsLoadBalancerV1ApiGetL7PolicyModelResponseL7PolicyModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiGetL7PolicyModelResponseL7PolicyModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerL7PoliciesAPIService.GetL7Policy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/l7policies/{l7_policy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"l7_policy_id"+"}", url.PathEscape(parameterValueToString(r.l7PolicyId, "l7PolicyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetL7PolicyRuleRequest struct {
	ctx        context.Context
	ApiService LoadBalancerL7PoliciesAPI
	l7PolicyId string
	l7RuleId   string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiGetL7PolicyRuleRequest) XAuthToken(xAuthToken string) ApiGetL7PolicyRuleRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiGetL7PolicyRuleRequest) Execute() (*Responsel7PolicyRuleModel, *http.Response, error) {
	return r.ApiService.GetL7PolicyRuleExecute(r)
}

/*
GetL7PolicyRule Get L7 policy rule

로드 밸런서의 특정 L7 정책(Policy)에 속한 단일 L7 규칙의 상세 정보를 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param l7PolicyId 조회할 L7 정책 ID
	@param l7RuleId 조회할 L7 규칙 ID
	@return ApiGetL7PolicyRuleRequest
*/
func (a *LoadBalancerL7PoliciesAPIService) GetL7PolicyRule(ctx context.Context, l7PolicyId string, l7RuleId string) ApiGetL7PolicyRuleRequest {
	return ApiGetL7PolicyRuleRequest{
		ApiService: a,
		ctx:        ctx,
		l7PolicyId: l7PolicyId,
		l7RuleId:   l7RuleId,
	}
}

// Execute executes the request
//
//	@return Responsel7PolicyRuleModel
func (a *LoadBalancerL7PoliciesAPIService) GetL7PolicyRuleExecute(r ApiGetL7PolicyRuleRequest) (*Responsel7PolicyRuleModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Responsel7PolicyRuleModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerL7PoliciesAPIService.GetL7PolicyRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/l7policies/{l7_policy_id}/rules/{l7_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"l7_policy_id"+"}", url.PathEscape(parameterValueToString(r.l7PolicyId, "l7PolicyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"l7_rule_id"+"}", url.PathEscape(parameterValueToString(r.l7RuleId, "l7RuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListL7PoliciesRequest struct {
	ctx                context.Context
	ApiService         LoadBalancerL7PoliciesAPI
	loadBalancerId     string
	listenerId         string
	xAuthToken         *string
	position           *int32
	action             *L7PolicyAction
	provisioningStatus *ProvisioningStatus
	operatingStatus    *LoadBalancerOperatingStatus
	name               *string
	sortKeys           *string
	sortDirs           *string
	limit              *int32
	offset             *int32
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiListL7PoliciesRequest) XAuthToken(xAuthToken string) ApiListL7PoliciesRequest {
	r.xAuthToken = &xAuthToken
	return r
}

// 정책 적용 우선순위 (숫자가 작을수록 우선순위 높음)
func (r ApiListL7PoliciesRequest) Position(position int32) ApiListL7PoliciesRequest {
	r.position = &position
	return r
}

// 정책 동작 유형 &lt;br/&gt; - &#x60;REDIRECT_PREFIX&#x60;: Prefix로 리디렉션 &lt;br/&gt; - &#x60;REDIRECT_TO_POOL&#x60;: 대상 풀로 리디렉션 &lt;br/&gt; - &#x60;REDIRECT_TO_URL&#x60;: URL로 리디렉션
func (r ApiListL7PoliciesRequest) Action(action L7PolicyAction) ApiListL7PoliciesRequest {
	r.action = &action
	return r
}

// 프로비저닝 상태 &lt;br/&gt; - &#x60;ACTIVE&#x60;: 활성 &lt;br/&gt; - &#x60;DELETED&#x60;: 삭제됨 &lt;br/&gt; - &#x60;ERROR&#x60;: 오류 &lt;br/&gt; - &#x60;PENDING_CREATE&#x60;: 생성 대기 중 &lt;br/&gt; - &#x60;PENDING_UPDATE&#x60;: 업데이트 대기 중 &lt;br/&gt; - &#x60;PENDING_DELETE&#x60;: 삭제 대기 중
func (r ApiListL7PoliciesRequest) ProvisioningStatus(provisioningStatus ProvisioningStatus) ApiListL7PoliciesRequest {
	r.provisioningStatus = &provisioningStatus
	return r
}

// 운영 상태 &lt;br/&gt; - &#x60;ONLINE&#x60;: 온라인 &lt;br/&gt; - &#x60;DRAINING&#x60;: 연결 종료 중 &lt;br/&gt; - &#x60;OFFLINE&#x60;: 오프라인 &lt;br/&gt; - &#x60;DEGRADED&#x60;: 성능 저하 &lt;br/&gt; - &#x60;ERROR&#x60;: 오류 &lt;br/&gt; - &#x60;NO_MONITOR&#x60;: 모니터링 없음
func (r ApiListL7PoliciesRequest) OperatingStatus(operatingStatus LoadBalancerOperatingStatus) ApiListL7PoliciesRequest {
	r.operatingStatus = &operatingStatus
	return r
}

// L7 정책 이름
func (r ApiListL7PoliciesRequest) Name(name string) ApiListL7PoliciesRequest {
	r.name = &name
	return r
}

// 정렬할 필드를 콤마(,)로 구분
func (r ApiListL7PoliciesRequest) SortKeys(sortKeys string) ApiListL7PoliciesRequest {
	r.sortKeys = &sortKeys
	return r
}

// 정렬 방향 (&#x60;asc&#x60;, &#x60;desc&#x60;)
func (r ApiListL7PoliciesRequest) SortDirs(sortDirs string) ApiListL7PoliciesRequest {
	r.sortDirs = &sortDirs
	return r
}

// 페이지당 최대 반환 항목 수
func (r ApiListL7PoliciesRequest) Limit(limit int32) ApiListL7PoliciesRequest {
	r.limit = &limit
	return r
}

// 조회 시작 위치
func (r ApiListL7PoliciesRequest) Offset(offset int32) ApiListL7PoliciesRequest {
	r.offset = &offset
	return r
}

func (r ApiListL7PoliciesRequest) Execute() (*L7PolicyListModel, *http.Response, error) {
	return r.ApiService.ListL7PoliciesExecute(r)
}

/*
ListL7Policies List L7 policies

지정한 로드 밸런서와 리스너에 연결된 L7 정책 목록을 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param loadBalancerId 조회할 로드 밸런서 ID
	@param listenerId 조회할 리스너 ID
	@return ApiListL7PoliciesRequest
*/
func (a *LoadBalancerL7PoliciesAPIService) ListL7Policies(ctx context.Context, loadBalancerId string, listenerId string) ApiListL7PoliciesRequest {
	return ApiListL7PoliciesRequest{
		ApiService:     a,
		ctx:            ctx,
		loadBalancerId: loadBalancerId,
		listenerId:     listenerId,
	}
}

// Execute executes the request
//
//	@return L7PolicyListModel
func (a *LoadBalancerL7PoliciesAPIService) ListL7PoliciesExecute(r ApiListL7PoliciesRequest) (*L7PolicyListModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *L7PolicyListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerL7PoliciesAPIService.ListL7Policies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/{load_balancer_id}/listeners/{listener_id}/l7policies"
	localVarPath = strings.Replace(localVarPath, "{"+"load_balancer_id"+"}", url.PathEscape(parameterValueToString(r.loadBalancerId, "loadBalancerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"listener_id"+"}", url.PathEscape(parameterValueToString(r.listenerId, "listenerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	if r.position != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "position", r.position, "form", "")
	}
	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "form", "")
	}
	if r.provisioningStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provisioning_status", r.provisioningStatus, "form", "")
	}
	if r.operatingStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operating_status", r.operatingStatus, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.sortKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_keys", r.sortKeys, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortKeys = &defaultValue
	}
	if r.sortDirs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dirs", r.sortDirs, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortDirs = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListL7PolicyRulesRequest struct {
	ctx        context.Context
	ApiService LoadBalancerL7PoliciesAPI
	l7PolicyId string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiListL7PolicyRulesRequest) XAuthToken(xAuthToken string) ApiListL7PolicyRulesRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiListL7PolicyRulesRequest) Execute() (*L7PolicyRuleListModel, *http.Response, error) {
	return r.ApiService.ListL7PolicyRulesExecute(r)
}

/*
ListL7PolicyRules List L7 policy rules

지정한 L7 정책에 정의된 규칙 목록을 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param l7PolicyId 조회할 L7 정책 ID
	@return ApiListL7PolicyRulesRequest
*/
func (a *LoadBalancerL7PoliciesAPIService) ListL7PolicyRules(ctx context.Context, l7PolicyId string) ApiListL7PolicyRulesRequest {
	return ApiListL7PolicyRulesRequest{
		ApiService: a,
		ctx:        ctx,
		l7PolicyId: l7PolicyId,
	}
}

// Execute executes the request
//
//	@return L7PolicyRuleListModel
func (a *LoadBalancerL7PoliciesAPIService) ListL7PolicyRulesExecute(r ApiListL7PolicyRulesRequest) (*L7PolicyRuleListModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *L7PolicyRuleListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerL7PoliciesAPIService.ListL7PolicyRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/l7policies/{l7_policy_id}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"l7_policy_id"+"}", url.PathEscape(parameterValueToString(r.l7PolicyId, "l7PolicyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateL7PolicyRequest struct {
	ctx                context.Context
	ApiService         LoadBalancerL7PoliciesAPI
	l7PolicyId         string
	xAuthToken         *string
	bodyUpdateL7Policy *BodyUpdateL7Policy
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUpdateL7PolicyRequest) XAuthToken(xAuthToken string) ApiUpdateL7PolicyRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUpdateL7PolicyRequest) BodyUpdateL7Policy(bodyUpdateL7Policy BodyUpdateL7Policy) ApiUpdateL7PolicyRequest {
	r.bodyUpdateL7Policy = &bodyUpdateL7Policy
	return r
}

func (r ApiUpdateL7PolicyRequest) Execute() (*BnsLoadBalancerV1ApiUpdateL7PolicyModelResponseL7PolicyModel, *http.Response, error) {
	return r.ApiService.UpdateL7PolicyExecute(r)
}

/*
UpdateL7Policy Update L7 policy

지정한 L7 정책을 수정합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param l7PolicyId 수정할 대상 L7 정책의 ID
	@return ApiUpdateL7PolicyRequest
*/
func (a *LoadBalancerL7PoliciesAPIService) UpdateL7Policy(ctx context.Context, l7PolicyId string) ApiUpdateL7PolicyRequest {
	return ApiUpdateL7PolicyRequest{
		ApiService: a,
		ctx:        ctx,
		l7PolicyId: l7PolicyId,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiUpdateL7PolicyModelResponseL7PolicyModel
func (a *LoadBalancerL7PoliciesAPIService) UpdateL7PolicyExecute(r ApiUpdateL7PolicyRequest) (*BnsLoadBalancerV1ApiUpdateL7PolicyModelResponseL7PolicyModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiUpdateL7PolicyModelResponseL7PolicyModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerL7PoliciesAPIService.UpdateL7Policy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/l7policies/{l7_policy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"l7_policy_id"+"}", url.PathEscape(parameterValueToString(r.l7PolicyId, "l7PolicyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyUpdateL7Policy == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateL7Policy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyUpdateL7Policy
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateL7PolicyRuleRequest struct {
	ctx                    context.Context
	ApiService             LoadBalancerL7PoliciesAPI
	l7PolicyId             string
	l7RuleId               string
	xAuthToken             *string
	bodyUpdateL7PolicyRule *BodyUpdateL7PolicyRule
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUpdateL7PolicyRuleRequest) XAuthToken(xAuthToken string) ApiUpdateL7PolicyRuleRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUpdateL7PolicyRuleRequest) BodyUpdateL7PolicyRule(bodyUpdateL7PolicyRule BodyUpdateL7PolicyRule) ApiUpdateL7PolicyRuleRequest {
	r.bodyUpdateL7PolicyRule = &bodyUpdateL7PolicyRule
	return r
}

func (r ApiUpdateL7PolicyRuleRequest) Execute() (*BnsLoadBalancerV1ApiUpdateL7PolicyRuleModelResponseL7PolicyRuleModel, *http.Response, error) {
	return r.ApiService.UpdateL7PolicyRuleExecute(r)
}

/*
UpdateL7PolicyRule Update L7 policy rule

L7 정책에 속한 특정 L7 규칙의 조건 및 속성을 수정합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param l7PolicyId 수정할 L7 정책 ID
	@param l7RuleId 수정할 L7 규칙 ID
	@return ApiUpdateL7PolicyRuleRequest
*/
func (a *LoadBalancerL7PoliciesAPIService) UpdateL7PolicyRule(ctx context.Context, l7PolicyId string, l7RuleId string) ApiUpdateL7PolicyRuleRequest {
	return ApiUpdateL7PolicyRuleRequest{
		ApiService: a,
		ctx:        ctx,
		l7PolicyId: l7PolicyId,
		l7RuleId:   l7RuleId,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiUpdateL7PolicyRuleModelResponseL7PolicyRuleModel
func (a *LoadBalancerL7PoliciesAPIService) UpdateL7PolicyRuleExecute(r ApiUpdateL7PolicyRuleRequest) (*BnsLoadBalancerV1ApiUpdateL7PolicyRuleModelResponseL7PolicyRuleModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiUpdateL7PolicyRuleModelResponseL7PolicyRuleModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerL7PoliciesAPIService.UpdateL7PolicyRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/l7policies/{l7_policy_id}/rules/{l7_rule_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"l7_policy_id"+"}", url.PathEscape(parameterValueToString(r.l7PolicyId, "l7PolicyId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"l7_rule_id"+"}", url.PathEscape(parameterValueToString(r.l7RuleId, "l7RuleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyUpdateL7PolicyRule == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateL7PolicyRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyUpdateL7PolicyRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
