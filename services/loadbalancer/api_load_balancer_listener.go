/*
Beyond Networking Service(BNS) Load Balancer API

BNS Load Balancer API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package loadbalancer

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type LoadBalancerListenerAPI interface {

	/*
		CreateListener Create listener

		지정한 로드 밸런서에 리스너를 생성합니다.

	:::info 안내
	- 리스너는 기존에 생성된 로드 밸런서 및 대상 그룹을 참조하여 구성해야 합니다.
	- HTTPS 리스너 설정 시에는 TLS 인증서 정보(`default_tls_container_ref`)가 필요합니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateListenerRequest
	*/
	CreateListener(ctx context.Context) ApiCreateListenerRequest

	// CreateListenerExecute executes the request
	//  @return BnsLoadBalancerV1ApiCreateListenerModelResponseListenerModel
	CreateListenerExecute(r ApiCreateListenerRequest) (*BnsLoadBalancerV1ApiCreateListenerModelResponseListenerModel, *http.Response, error)

	/*
		DeleteListener Delete listener

		특정 로드 밸런서의 리스너를 삭제합니다.
	리스너는 클라이언트 요청을 수신하는 역할을 하므로, 삭제 시 연결된 정책 및 대상 그룹에 영향을 줄 수 있습니다.

	:::caution 주의
	- 삭제된 리스너는 복구할 수 없습니다.
	- 리스너에 연결된 정책, 대상 그룹, 인증서 설정 등을 함께 검토한 후 삭제를 진행하세요.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param listenerId 삭제할 리스너의 고유 ID
		@return ApiDeleteListenerRequest
	*/
	DeleteListener(ctx context.Context, listenerId string) ApiDeleteListenerRequest

	// DeleteListenerExecute executes the request
	DeleteListenerExecute(r ApiDeleteListenerRequest) (*http.Response, error)

	/*
		GetListener Get listener

		로드 밸런서에 설정된 리스너의 상세 정보를 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param listenerId 조회할 리스너 ID
		@return ApiGetListenerRequest
	*/
	GetListener(ctx context.Context, listenerId string) ApiGetListenerRequest

	// GetListenerExecute executes the request
	//  @return BnsLoadBalancerV1ApiGetListenerModelResponseListenerModel
	GetListenerExecute(r ApiGetListenerRequest) (*BnsLoadBalancerV1ApiGetListenerModelResponseListenerModel, *http.Response, error)

	/*
		ListListeners List listeners

		프로젝트 내 전체 리스너 목록을 조회합니다.<br/>
	특정 로드 밸런서에 설정된 리스너를 확인하려면 [로드 밸런서 상세 정보 조회 API](https://docs.kakaocloud.com/openapi/bns/lb/get-load-balancer)를 사용하세요.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListListenersRequest
	*/
	ListListeners(ctx context.Context) ApiListListenersRequest

	// ListListenersExecute executes the request
	//  @return ListenerListModel
	ListListenersExecute(r ApiListListenersRequest) (*ListenerListModel, *http.Response, error)

	/*
		UpdateListener Update listener

		로드 밸런서의 특정 리스너 설정을 수정합니다.

	:::info 안내
	- HTTPS 리스너일 경우, `default_tls_container_ref`를 반드시 설정해야 하며, 필요에 따라 SNI 인증서를 함께 설정할 수 있습니다.
	- TCP/UDP 리스너는 L7 정책을 사용할 수 없으며, L7 관련 속성은 무시됩니다.
	:::

	:::caution 주의
	- 리스너가 연결된 로드 밸런서의 상태가 `ACTIVE`가 아닌 경우 수정이 제한될 수 있습니다.
	- 연결 제한 수(`connection_limit`)를 `-1`로 설정하면 무제한 연결이 허용되지만, 실제 처리 성능은 인스턴스 스펙에 따라 달라질 수 있습니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param listenerId 수정할 리스너 ID
		@return ApiUpdateListenerRequest
	*/
	UpdateListener(ctx context.Context, listenerId string) ApiUpdateListenerRequest

	// UpdateListenerExecute executes the request
	//  @return ResponseEditListenerModel
	UpdateListenerExecute(r ApiUpdateListenerRequest) (*ResponseEditListenerModel, *http.Response, error)
}

// LoadBalancerListenerAPIService LoadBalancerListenerAPI service
type LoadBalancerListenerAPIService service

type ApiCreateListenerRequest struct {
	ctx                context.Context
	ApiService         LoadBalancerListenerAPI
	xAuthToken         *string
	bodyCreateListener *BodyCreateListener
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiCreateListenerRequest) XAuthToken(xAuthToken string) ApiCreateListenerRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiCreateListenerRequest) BodyCreateListener(bodyCreateListener BodyCreateListener) ApiCreateListenerRequest {
	r.bodyCreateListener = &bodyCreateListener
	return r
}

func (r ApiCreateListenerRequest) Execute() (*BnsLoadBalancerV1ApiCreateListenerModelResponseListenerModel, *http.Response, error) {
	return r.ApiService.CreateListenerExecute(r)
}

/*
CreateListener Create listener

지정한 로드 밸런서에 리스너를 생성합니다.

:::info 안내
- 리스너는 기존에 생성된 로드 밸런서 및 대상 그룹을 참조하여 구성해야 합니다.
- HTTPS 리스너 설정 시에는 TLS 인증서 정보(`default_tls_container_ref`)가 필요합니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateListenerRequest
*/
func (a *LoadBalancerListenerAPIService) CreateListener(ctx context.Context) ApiCreateListenerRequest {
	return ApiCreateListenerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiCreateListenerModelResponseListenerModel
func (a *LoadBalancerListenerAPIService) CreateListenerExecute(r ApiCreateListenerRequest) (*BnsLoadBalancerV1ApiCreateListenerModelResponseListenerModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiCreateListenerModelResponseListenerModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerListenerAPIService.CreateListener")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/listeners"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyCreateListener == nil {
		return localVarReturnValue, nil, reportError("bodyCreateListener is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyCreateListener
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteListenerRequest struct {
	ctx        context.Context
	ApiService LoadBalancerListenerAPI
	listenerId string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiDeleteListenerRequest) XAuthToken(xAuthToken string) ApiDeleteListenerRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiDeleteListenerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListenerExecute(r)
}

/*
DeleteListener Delete listener

특정 로드 밸런서의 리스너를 삭제합니다.
리스너는 클라이언트 요청을 수신하는 역할을 하므로, 삭제 시 연결된 정책 및 대상 그룹에 영향을 줄 수 있습니다.

:::caution 주의
- 삭제된 리스너는 복구할 수 없습니다.
- 리스너에 연결된 정책, 대상 그룹, 인증서 설정 등을 함께 검토한 후 삭제를 진행하세요.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listenerId 삭제할 리스너의 고유 ID
	@return ApiDeleteListenerRequest
*/
func (a *LoadBalancerListenerAPIService) DeleteListener(ctx context.Context, listenerId string) ApiDeleteListenerRequest {
	return ApiDeleteListenerRequest{
		ApiService: a,
		ctx:        ctx,
		listenerId: listenerId,
	}
}

// Execute executes the request
func (a *LoadBalancerListenerAPIService) DeleteListenerExecute(r ApiDeleteListenerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerListenerAPIService.DeleteListener")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/listeners/{listener_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listener_id"+"}", url.PathEscape(parameterValueToString(r.listenerId, "listenerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetListenerRequest struct {
	ctx        context.Context
	ApiService LoadBalancerListenerAPI
	listenerId string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiGetListenerRequest) XAuthToken(xAuthToken string) ApiGetListenerRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiGetListenerRequest) Execute() (*BnsLoadBalancerV1ApiGetListenerModelResponseListenerModel, *http.Response, error) {
	return r.ApiService.GetListenerExecute(r)
}

/*
GetListener Get listener

로드 밸런서에 설정된 리스너의 상세 정보를 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listenerId 조회할 리스너 ID
	@return ApiGetListenerRequest
*/
func (a *LoadBalancerListenerAPIService) GetListener(ctx context.Context, listenerId string) ApiGetListenerRequest {
	return ApiGetListenerRequest{
		ApiService: a,
		ctx:        ctx,
		listenerId: listenerId,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiGetListenerModelResponseListenerModel
func (a *LoadBalancerListenerAPIService) GetListenerExecute(r ApiGetListenerRequest) (*BnsLoadBalancerV1ApiGetListenerModelResponseListenerModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiGetListenerModelResponseListenerModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerListenerAPIService.GetListener")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/listeners/{listener_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listener_id"+"}", url.PathEscape(parameterValueToString(r.listenerId, "listenerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListListenersRequest struct {
	ctx                context.Context
	ApiService         LoadBalancerListenerAPI
	xAuthToken         *string
	id                 *string
	loadBalancerId     *string
	protocol           *Protocol
	protocolPort       *string
	provisioningStatus *ProvisioningStatus
	operatingStatus    *LoadBalancerOperatingStatus
	secretName         *string
	secretId           *string
	tlsCertificateId   *string
	createdAt          *string
	updatedAt          *string
	sortKeys           *string
	sortDirs           *string
	limit              *int32
	offset             *int32
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiListListenersRequest) XAuthToken(xAuthToken string) ApiListListenersRequest {
	r.xAuthToken = &xAuthToken
	return r
}

// 리스너의 고유 ID
func (r ApiListListenersRequest) Id(id string) ApiListListenersRequest {
	r.id = &id
	return r
}

// 연결된 로드 밸런서 ID
func (r ApiListListenersRequest) LoadBalancerId(loadBalancerId string) ApiListListenersRequest {
	r.loadBalancerId = &loadBalancerId
	return r
}

// 리스너가 사용하는 프로토콜 &lt;br/&gt; - &#x60;HTTP&#x60;: HTTP &lt;br/&gt; - &#x60;TCP&#x60;: TCP &lt;br/&gt; - &#x60;UDP&#x60;: UDP &lt;br/&gt; - &#x60;TERMINATED_HTTPS&#x60;: SSL 종료 처리된 HTTPS
func (r ApiListListenersRequest) Protocol(protocol Protocol) ApiListListenersRequest {
	r.protocol = &protocol
	return r
}

// 리스너가 수신하는 포트 번호
func (r ApiListListenersRequest) ProtocolPort(protocolPort string) ApiListListenersRequest {
	r.protocolPort = &protocolPort
	return r
}

// 프로비저닝 상태 &lt;br/&gt; - &#x60;ACTIVE&#x60;: 활성 &lt;br/&gt; - &#x60;DELETED&#x60;: 삭제됨 &lt;br/&gt; - &#x60;ERROR&#x60;: 오류 &lt;br/&gt; - &#x60;PENDING_CREATE&#x60;: 생성 대기 중 &lt;br/&gt; - &#x60;PENDING_UPDATE&#x60;: 업데이트 대기 중 &lt;br/&gt; - &#x60;PENDING_DELETE&#x60;: 삭제 대기 중
func (r ApiListListenersRequest) ProvisioningStatus(provisioningStatus ProvisioningStatus) ApiListListenersRequest {
	r.provisioningStatus = &provisioningStatus
	return r
}

// 운영 상태 &lt;br/&gt; - &#x60;ONLINE&#x60;: 온라인 &lt;br/&gt; - &#x60;DRAINING&#x60;: 연결 종료 중 &lt;br/&gt; - &#x60;OFFLINE&#x60;: 오프라인 &lt;br/&gt; - &#x60;DEGRADED&#x60;: 성능 저하 &lt;br/&gt; - &#x60;ERROR&#x60;: 오류 &lt;br/&gt; - &#x60;NO_MONITOR&#x60;: 모니터링 없음
func (r ApiListListenersRequest) OperatingStatus(operatingStatus LoadBalancerOperatingStatus) ApiListListenersRequest {
	r.operatingStatus = &operatingStatus
	return r
}

// TLS 인증서 이름
func (r ApiListListenersRequest) SecretName(secretName string) ApiListListenersRequest {
	r.secretName = &secretName
	return r
}

// TLS 인증서 ID
func (r ApiListListenersRequest) SecretId(secretId string) ApiListListenersRequest {
	r.secretId = &secretId
	return r
}

// 리스너에 연결된 TLS 인증서 ID
func (r ApiListListenersRequest) TlsCertificateId(tlsCertificateId string) ApiListListenersRequest {
	r.tlsCertificateId = &tlsCertificateId
	return r
}

// 리소스가 생성된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListListenersRequest) CreatedAt(createdAt string) ApiListListenersRequest {
	r.createdAt = &createdAt
	return r
}

// 리소스가 마지막으로 수정된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListListenersRequest) UpdatedAt(updatedAt string) ApiListListenersRequest {
	r.updatedAt = &updatedAt
	return r
}

// 정렬할 필드를 콤마(,)로 구분
func (r ApiListListenersRequest) SortKeys(sortKeys string) ApiListListenersRequest {
	r.sortKeys = &sortKeys
	return r
}

// 정렬 방향 (&#x60;asc&#x60;, &#x60;desc&#x60;)
func (r ApiListListenersRequest) SortDirs(sortDirs string) ApiListListenersRequest {
	r.sortDirs = &sortDirs
	return r
}

// 페이지당 최대 반환 항목 수
func (r ApiListListenersRequest) Limit(limit int32) ApiListListenersRequest {
	r.limit = &limit
	return r
}

// 조회 시작 위치
func (r ApiListListenersRequest) Offset(offset int32) ApiListListenersRequest {
	r.offset = &offset
	return r
}

func (r ApiListListenersRequest) Execute() (*ListenerListModel, *http.Response, error) {
	return r.ApiService.ListListenersExecute(r)
}

/*
ListListeners List listeners

프로젝트 내 전체 리스너 목록을 조회합니다.<br/>
특정 로드 밸런서에 설정된 리스너를 확인하려면 [로드 밸런서 상세 정보 조회 API](https://docs.kakaocloud.com/openapi/bns/lb/get-load-balancer)를 사용하세요.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListListenersRequest
*/
func (a *LoadBalancerListenerAPIService) ListListeners(ctx context.Context) ApiListListenersRequest {
	return ApiListListenersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListenerListModel
func (a *LoadBalancerListenerAPIService) ListListenersExecute(r ApiListListenersRequest) (*ListenerListModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListenerListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerListenerAPIService.ListListeners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/listeners"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.loadBalancerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "load_balancer_id", r.loadBalancerId, "form", "")
	}
	if r.protocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", r.protocol, "form", "")
	}
	if r.protocolPort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_port", r.protocolPort, "form", "")
	}
	if r.provisioningStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provisioning_status", r.provisioningStatus, "form", "")
	}
	if r.operatingStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operating_status", r.operatingStatus, "form", "")
	}
	if r.secretName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secret_name", r.secretName, "form", "")
	}
	if r.secretId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "secret_id", r.secretId, "form", "")
	}
	if r.tlsCertificateId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tls_certificate_id", r.tlsCertificateId, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	if r.sortKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_keys", r.sortKeys, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortKeys = &defaultValue
	}
	if r.sortDirs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dirs", r.sortDirs, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortDirs = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateListenerRequest struct {
	ctx                context.Context
	ApiService         LoadBalancerListenerAPI
	listenerId         string
	xAuthToken         *string
	bodyUpdateListener *BodyUpdateListener
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUpdateListenerRequest) XAuthToken(xAuthToken string) ApiUpdateListenerRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUpdateListenerRequest) BodyUpdateListener(bodyUpdateListener BodyUpdateListener) ApiUpdateListenerRequest {
	r.bodyUpdateListener = &bodyUpdateListener
	return r
}

func (r ApiUpdateListenerRequest) Execute() (*ResponseEditListenerModel, *http.Response, error) {
	return r.ApiService.UpdateListenerExecute(r)
}

/*
UpdateListener Update listener

로드 밸런서의 특정 리스너 설정을 수정합니다.

:::info 안내
- HTTPS 리스너일 경우, `default_tls_container_ref`를 반드시 설정해야 하며, 필요에 따라 SNI 인증서를 함께 설정할 수 있습니다.
- TCP/UDP 리스너는 L7 정책을 사용할 수 없으며, L7 관련 속성은 무시됩니다.
:::

:::caution 주의
- 리스너가 연결된 로드 밸런서의 상태가 `ACTIVE`가 아닌 경우 수정이 제한될 수 있습니다.
- 연결 제한 수(`connection_limit`)를 `-1`로 설정하면 무제한 연결이 허용되지만, 실제 처리 성능은 인스턴스 스펙에 따라 달라질 수 있습니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param listenerId 수정할 리스너 ID
	@return ApiUpdateListenerRequest
*/
func (a *LoadBalancerListenerAPIService) UpdateListener(ctx context.Context, listenerId string) ApiUpdateListenerRequest {
	return ApiUpdateListenerRequest{
		ApiService: a,
		ctx:        ctx,
		listenerId: listenerId,
	}
}

// Execute executes the request
//
//	@return ResponseEditListenerModel
func (a *LoadBalancerListenerAPIService) UpdateListenerExecute(r ApiUpdateListenerRequest) (*ResponseEditListenerModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseEditListenerModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerListenerAPIService.UpdateListener")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/listeners/{listener_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"listener_id"+"}", url.PathEscape(parameterValueToString(r.listenerId, "listenerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyUpdateListener == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateListener is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyUpdateListener
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
