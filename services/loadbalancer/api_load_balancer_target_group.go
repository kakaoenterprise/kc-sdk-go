/*
Beyond Networking Service(BNS) Load Balancer API

BNS Load Balancer API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package loadbalancer

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type LoadBalancerTargetGroupAPI interface {

	/*
		AddTarget Add target

		로드 밸런서 대상 그룹에 새로운 대상 인스턴스를 추가합니다. <br/>
	지정된 인스턴스는 지정된 프로토콜 포트로 트래픽을 수신하며, 헬스 체크는 별도의 모니터링 포트로 수행됩니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param targetGroupId 대상을 추가할 대상 그룹의 ID
		@return ApiAddTargetRequest
	*/
	AddTarget(ctx context.Context, targetGroupId string) ApiAddTargetRequest

	// AddTargetExecute executes the request
	//  @return BnsLoadBalancerV1ApiAddTargetModelResponseTargetGroupMemberModel
	AddTargetExecute(r ApiAddTargetRequest) (*BnsLoadBalancerV1ApiAddTargetModelResponseTargetGroupMemberModel, *http.Response, error)

	/*
		CreateHealthMonitor Create health monitor

		지정한 대상 그룹에 헬스 모니터를 생성합니다.

	:::info 안내
	- 헬스 체크 방식(type)에 따라 `http_method`, `expected_codes`, `url_path` 등의 필드는 HTTP/HTTPS에서만 적용됩니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateHealthMonitorRequest
	*/
	CreateHealthMonitor(ctx context.Context) ApiCreateHealthMonitorRequest

	// CreateHealthMonitorExecute executes the request
	//  @return BnsLoadBalancerV1ApiCreateHealthMonitorModelResponseHealthMonitorModel
	CreateHealthMonitorExecute(r ApiCreateHealthMonitorRequest) (*BnsLoadBalancerV1ApiCreateHealthMonitorModelResponseHealthMonitorModel, *http.Response, error)

	/*
		CreateTargetGroup Create target group

		새로운 로드 밸런서 대상 그룹을 생성합니다. <br/>
	대상 그룹 생성 시 멤버(대상 인스턴스)는 함께 지정할 수 없습니다. [대상 인스턴스 추가 API](https://docs.kakaocloud.com/openapi/bns/lb/add-target)를 참고하여 별도로 추가하세요.

	:::info 안내
	- 세션은 리스너 프로토콜과 대상 그룹 프로토콜 조합이 `HTTP-HTTP`, `TCP-TCP`, `UDP-UDP`인 경우에만 설정할 수 있습니다.
	- 로드 밸런서의 유형(ALB, NLB 등)에 따라 선택 가능한 프로토콜이 다르므로, 사전에 [로드 밸런서와 호환되는 프로토콜](https://docs.kakaocloud.com/service/bns/lb/main/lb-target-group#target-group-protocol-and-routing-configuration)을 확인해 주세요.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateTargetGroupRequest
	*/
	CreateTargetGroup(ctx context.Context) ApiCreateTargetGroupRequest

	// CreateTargetGroupExecute executes the request
	//  @return BnsLoadBalancerV1ApiCreateTargetGroupModelResponseTargetGroupModel
	CreateTargetGroupExecute(r ApiCreateTargetGroupRequest) (*BnsLoadBalancerV1ApiCreateTargetGroupModelResponseTargetGroupModel, *http.Response, error)

	/*
		DeleteHealthMonitor Delete health monitor

		지정한 헬스 모니터(Health Monitor)를 삭제합니다.
	삭제 시 해당 모니터는 연결된 대상 그룹에서도 제거됩니다.

	:::caution 주의
	- 헬스 모니터가 삭제되면 해당 모니터를 기반으로 동작하던 대상 그룹의 상태 점검 기능도 함께 중단됩니다.
	- 서비스 가용성에 영향을 줄 수 있으므로 삭제 전 의존성을 반드시 확인해야 합니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param healthMonitorId 삭제할 헬스 모니터의 ID
		@return ApiDeleteHealthMonitorRequest
	*/
	DeleteHealthMonitor(ctx context.Context, healthMonitorId string) ApiDeleteHealthMonitorRequest

	// DeleteHealthMonitorExecute executes the request
	DeleteHealthMonitorExecute(r ApiDeleteHealthMonitorRequest) (*http.Response, error)

	/*
		DeleteTargetGroup Delete target group

		지정한 로드 밸런서의 대상 그룹을 삭제합니다.

	:::caution 주의
	대상 그룹을 삭제하면 해당 그룹과 연결된 리스너 설정, 헬스 모니터 등도 영향을 받을 수 있으므로 삭제 전 구성을 반드시 확인해야 합니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param targetGroupId 삭제할 대상 그룹의 ID
		@return ApiDeleteTargetGroupRequest
	*/
	DeleteTargetGroup(ctx context.Context, targetGroupId string) ApiDeleteTargetGroupRequest

	// DeleteTargetGroupExecute executes the request
	DeleteTargetGroupExecute(r ApiDeleteTargetGroupRequest) (*http.Response, error)

	/*
		GetTargetGroup Get target group

		지정한 대상 그룹 ID에 해당하는 로드 밸런서 대상 그룹의 상세 정보를 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param targetGroupId 조회할 대상 그룹 ID
		@return ApiGetTargetGroupRequest
	*/
	GetTargetGroup(ctx context.Context, targetGroupId string) ApiGetTargetGroupRequest

	// GetTargetGroupExecute executes the request
	//  @return TargetGroupResponseModel
	GetTargetGroupExecute(r ApiGetTargetGroupRequest) (*TargetGroupResponseModel, *http.Response, error)

	/*
		GetTargetGroupHealthCheckSubnets Get target group health check subnets

		대상 그룹의 헬스 체크에 사용되는 IP 목록을 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param targetGroupId 대상 그룹 ID
		@return ApiGetTargetGroupHealthCheckSubnetsRequest
	*/
	GetTargetGroupHealthCheckSubnets(ctx context.Context, targetGroupId string) ApiGetTargetGroupHealthCheckSubnetsRequest

	// GetTargetGroupHealthCheckSubnetsExecute executes the request
	//  @return ResponseHealthCheckSubnetsModel
	GetTargetGroupHealthCheckSubnetsExecute(r ApiGetTargetGroupHealthCheckSubnetsRequest) (*ResponseHealthCheckSubnetsModel, *http.Response, error)

	/*
		GetTargetGroupHealthMonitor Get target group health monitor

		지정한 헬스 모니터 ID에 해당하는 대상 그룹 헬스 모니터의 상세 정보를 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param healthMonitorId 조회할 헬스 모니터 ID
		@return ApiGetTargetGroupHealthMonitorRequest
	*/
	GetTargetGroupHealthMonitor(ctx context.Context, healthMonitorId string) ApiGetTargetGroupHealthMonitorRequest

	// GetTargetGroupHealthMonitorExecute executes the request
	//  @return BnsLoadBalancerV1ApiGetTargetGroupHealthMonitorModelResponseHealthMonitorModel
	GetTargetGroupHealthMonitorExecute(r ApiGetTargetGroupHealthMonitorRequest) (*BnsLoadBalancerV1ApiGetTargetGroupHealthMonitorModelResponseHealthMonitorModel, *http.Response, error)

	/*
		ListTargetGroups List target groups

		로드 밸런서에 등록된 대상 그룹 목록을 조회합니다.

	:::caution 주의
	대상 그룹은 로드 밸런서의 트래픽 분산 대상이므로, 구성 변경 시 서비스에 영향을 줄 수 있습니다. 프로비저닝 상태를 사전에 점검하세요.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListTargetGroupsRequest
	*/
	ListTargetGroups(ctx context.Context) ApiListTargetGroupsRequest

	// ListTargetGroupsExecute executes the request
	//  @return TargetGroupListModel
	ListTargetGroupsExecute(r ApiListTargetGroupsRequest) (*TargetGroupListModel, *http.Response, error)

	/*
		ListTargetsInTargetGroup List targets in target group

		특정 로드 밸런서 대상 그룹에 포함된 대상(Target) 인스턴스의 목록을 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param targetGroupId 대상 그룹 ID
		@return ApiListTargetsInTargetGroupRequest
	*/
	ListTargetsInTargetGroup(ctx context.Context, targetGroupId string) ApiListTargetsInTargetGroupRequest

	// ListTargetsInTargetGroupExecute executes the request
	//  @return TargetGroupMemberListModel
	ListTargetsInTargetGroupExecute(r ApiListTargetsInTargetGroupRequest) (*TargetGroupMemberListModel, *http.Response, error)

	/*
		RemoveTarget Remove target

		로드 밸런서 대상 그룹에서 지정한 대상 인스턴스를 삭제합니다.
	삭제된 대상은 더 이상 트래픽 분산 대상에 포함되지 않습니다.

	:::info 안내
	대상을 삭제하면 해당 인스턴스로의 트래픽 전달이 즉시 중단됩니다. 삭제 전 서비스 영향도를 충분히 고려하세요.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param targetGroupId 대상 그룹 ID
		@param memberId 삭제할 대상 인스턴스의 ID
		@return ApiRemoveTargetRequest
	*/
	RemoveTarget(ctx context.Context, targetGroupId string, memberId string) ApiRemoveTargetRequest

	// RemoveTargetExecute executes the request
	RemoveTargetExecute(r ApiRemoveTargetRequest) (*http.Response, error)

	/*
		UpdateHealthMonitor Update health monitor

		지정한 헬스 모니터의 설정을 수정합니다.

	:::info 안내
	- 지원하지 않는 `http_method` 또는 부정확한 `expected_codes` 값을 설정할 경우, 트래픽 라우팅 오류가 발생할 수 있습니다.
	- 설정 변경은 대상 그룹 전체에 영향을 주며, 적용 즉시 다음 헬스 체크 주기부터 반영됩니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param healthMonitorId 수정 대상 헬스 모니터의 ID
		@return ApiUpdateHealthMonitorRequest
	*/
	UpdateHealthMonitor(ctx context.Context, healthMonitorId string) ApiUpdateHealthMonitorRequest

	// UpdateHealthMonitorExecute executes the request
	//  @return BnsLoadBalancerV1ApiUpdateHealthMonitorModelResponseHealthMonitorModel
	UpdateHealthMonitorExecute(r ApiUpdateHealthMonitorRequest) (*BnsLoadBalancerV1ApiUpdateHealthMonitorModelResponseHealthMonitorModel, *http.Response, error)

	/*
		UpdateTarget Update target

		로드 밸런서 대상 그룹의 특정 대상 인스턴스 정보를 수정합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param targetGroupId 대상 그룹 ID
		@param memberId 수정할 대상 인스턴스의 ID
		@return ApiUpdateTargetRequest
	*/
	UpdateTarget(ctx context.Context, targetGroupId string, memberId string) ApiUpdateTargetRequest

	// UpdateTargetExecute executes the request
	//  @return BnsLoadBalancerV1ApiUpdateTargetModelResponseTargetGroupMemberModel
	UpdateTargetExecute(r ApiUpdateTargetRequest) (*BnsLoadBalancerV1ApiUpdateTargetModelResponseTargetGroupMemberModel, *http.Response, error)

	/*
		UpdateTargetGroup Update target group

		로드 밸런서에 연결된 대상 그룹의 정보를 수정합니다.

	:::info 안내
	- 세션은 대상 그룹과 리스너가 연결된 경우에만 설정할 수 있습니다.
	- 세션은 리스너 프로토콜과 대상 그룹 프로토콜 조합이 `HTTP-HTTP`, `TCP-TCP`, `UDP-UDP`인 경우에만 설정할 수 있습니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param targetGroupId 수정할 대상 그룹의 ID
		@return ApiUpdateTargetGroupRequest
	*/
	UpdateTargetGroup(ctx context.Context, targetGroupId string) ApiUpdateTargetGroupRequest

	// UpdateTargetGroupExecute executes the request
	//  @return BnsLoadBalancerV1ApiUpdateTargetGroupModelResponseTargetGroupModel
	UpdateTargetGroupExecute(r ApiUpdateTargetGroupRequest) (*BnsLoadBalancerV1ApiUpdateTargetGroupModelResponseTargetGroupModel, *http.Response, error)

	/*
		UpdateTargets Update targets

		로드 밸런서 대상 그룹의 여러 대상 인스턴스 정보를 일괄 수정합니다. <br/>
	기존 대상 인스턴스를 수정/삭제하거나, 새로운 대상 인스턴스를 추가할 수 있습니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param targetGroupId 수정할 대상 인스턴스가 속한 대상 그룹의 ID
		@return ApiUpdateTargetsRequest
	*/
	UpdateTargets(ctx context.Context, targetGroupId string) ApiUpdateTargetsRequest

	// UpdateTargetsExecute executes the request
	//  @return interface{}
	UpdateTargetsExecute(r ApiUpdateTargetsRequest) (interface{}, *http.Response, error)
}

// LoadBalancerTargetGroupAPIService LoadBalancerTargetGroupAPI service
type LoadBalancerTargetGroupAPIService service

type ApiAddTargetRequest struct {
	ctx           context.Context
	ApiService    LoadBalancerTargetGroupAPI
	targetGroupId string
	xAuthToken    *string
	bodyAddTarget *BodyAddTarget
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiAddTargetRequest) XAuthToken(xAuthToken string) ApiAddTargetRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiAddTargetRequest) BodyAddTarget(bodyAddTarget BodyAddTarget) ApiAddTargetRequest {
	r.bodyAddTarget = &bodyAddTarget
	return r
}

func (r ApiAddTargetRequest) Execute() (*BnsLoadBalancerV1ApiAddTargetModelResponseTargetGroupMemberModel, *http.Response, error) {
	return r.ApiService.AddTargetExecute(r)
}

/*
AddTarget Add target

로드 밸런서 대상 그룹에 새로운 대상 인스턴스를 추가합니다. <br/>
지정된 인스턴스는 지정된 프로토콜 포트로 트래픽을 수신하며, 헬스 체크는 별도의 모니터링 포트로 수행됩니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetGroupId 대상을 추가할 대상 그룹의 ID
	@return ApiAddTargetRequest
*/
func (a *LoadBalancerTargetGroupAPIService) AddTarget(ctx context.Context, targetGroupId string) ApiAddTargetRequest {
	return ApiAddTargetRequest{
		ApiService:    a,
		ctx:           ctx,
		targetGroupId: targetGroupId,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiAddTargetModelResponseTargetGroupMemberModel
func (a *LoadBalancerTargetGroupAPIService) AddTargetExecute(r ApiAddTargetRequest) (*BnsLoadBalancerV1ApiAddTargetModelResponseTargetGroupMemberModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiAddTargetModelResponseTargetGroupMemberModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.AddTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups/{target_group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"target_group_id"+"}", url.PathEscape(parameterValueToString(r.targetGroupId, "targetGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyAddTarget == nil {
		return localVarReturnValue, nil, reportError("bodyAddTarget is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyAddTarget
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateHealthMonitorRequest struct {
	ctx                     context.Context
	ApiService              LoadBalancerTargetGroupAPI
	xAuthToken              *string
	bodyCreateHealthMonitor *BodyCreateHealthMonitor
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiCreateHealthMonitorRequest) XAuthToken(xAuthToken string) ApiCreateHealthMonitorRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiCreateHealthMonitorRequest) BodyCreateHealthMonitor(bodyCreateHealthMonitor BodyCreateHealthMonitor) ApiCreateHealthMonitorRequest {
	r.bodyCreateHealthMonitor = &bodyCreateHealthMonitor
	return r
}

func (r ApiCreateHealthMonitorRequest) Execute() (*BnsLoadBalancerV1ApiCreateHealthMonitorModelResponseHealthMonitorModel, *http.Response, error) {
	return r.ApiService.CreateHealthMonitorExecute(r)
}

/*
CreateHealthMonitor Create health monitor

지정한 대상 그룹에 헬스 모니터를 생성합니다.

:::info 안내
- 헬스 체크 방식(type)에 따라 `http_method`, `expected_codes`, `url_path` 등의 필드는 HTTP/HTTPS에서만 적용됩니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateHealthMonitorRequest
*/
func (a *LoadBalancerTargetGroupAPIService) CreateHealthMonitor(ctx context.Context) ApiCreateHealthMonitorRequest {
	return ApiCreateHealthMonitorRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiCreateHealthMonitorModelResponseHealthMonitorModel
func (a *LoadBalancerTargetGroupAPIService) CreateHealthMonitorExecute(r ApiCreateHealthMonitorRequest) (*BnsLoadBalancerV1ApiCreateHealthMonitorModelResponseHealthMonitorModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiCreateHealthMonitorModelResponseHealthMonitorModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.CreateHealthMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/health-monitors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyCreateHealthMonitor == nil {
		return localVarReturnValue, nil, reportError("bodyCreateHealthMonitor is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyCreateHealthMonitor
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTargetGroupRequest struct {
	ctx                   context.Context
	ApiService            LoadBalancerTargetGroupAPI
	xAuthToken            *string
	bodyCreateTargetGroup *BodyCreateTargetGroup
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiCreateTargetGroupRequest) XAuthToken(xAuthToken string) ApiCreateTargetGroupRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiCreateTargetGroupRequest) BodyCreateTargetGroup(bodyCreateTargetGroup BodyCreateTargetGroup) ApiCreateTargetGroupRequest {
	r.bodyCreateTargetGroup = &bodyCreateTargetGroup
	return r
}

func (r ApiCreateTargetGroupRequest) Execute() (*BnsLoadBalancerV1ApiCreateTargetGroupModelResponseTargetGroupModel, *http.Response, error) {
	return r.ApiService.CreateTargetGroupExecute(r)
}

/*
CreateTargetGroup Create target group

새로운 로드 밸런서 대상 그룹을 생성합니다. <br/>
대상 그룹 생성 시 멤버(대상 인스턴스)는 함께 지정할 수 없습니다. [대상 인스턴스 추가 API](https://docs.kakaocloud.com/openapi/bns/lb/add-target)를 참고하여 별도로 추가하세요.

:::info 안내
- 세션은 리스너 프로토콜과 대상 그룹 프로토콜 조합이 `HTTP-HTTP`, `TCP-TCP`, `UDP-UDP`인 경우에만 설정할 수 있습니다.
- 로드 밸런서의 유형(ALB, NLB 등)에 따라 선택 가능한 프로토콜이 다르므로, 사전에 [로드 밸런서와 호환되는 프로토콜](https://docs.kakaocloud.com/service/bns/lb/main/lb-target-group#target-group-protocol-and-routing-configuration)을 확인해 주세요.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateTargetGroupRequest
*/
func (a *LoadBalancerTargetGroupAPIService) CreateTargetGroup(ctx context.Context) ApiCreateTargetGroupRequest {
	return ApiCreateTargetGroupRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiCreateTargetGroupModelResponseTargetGroupModel
func (a *LoadBalancerTargetGroupAPIService) CreateTargetGroupExecute(r ApiCreateTargetGroupRequest) (*BnsLoadBalancerV1ApiCreateTargetGroupModelResponseTargetGroupModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiCreateTargetGroupModelResponseTargetGroupModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.CreateTargetGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyCreateTargetGroup == nil {
		return localVarReturnValue, nil, reportError("bodyCreateTargetGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyCreateTargetGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteHealthMonitorRequest struct {
	ctx             context.Context
	ApiService      LoadBalancerTargetGroupAPI
	healthMonitorId string
	xAuthToken      *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiDeleteHealthMonitorRequest) XAuthToken(xAuthToken string) ApiDeleteHealthMonitorRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiDeleteHealthMonitorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteHealthMonitorExecute(r)
}

/*
DeleteHealthMonitor Delete health monitor

지정한 헬스 모니터(Health Monitor)를 삭제합니다.
삭제 시 해당 모니터는 연결된 대상 그룹에서도 제거됩니다.

:::caution 주의
- 헬스 모니터가 삭제되면 해당 모니터를 기반으로 동작하던 대상 그룹의 상태 점검 기능도 함께 중단됩니다.
- 서비스 가용성에 영향을 줄 수 있으므로 삭제 전 의존성을 반드시 확인해야 합니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param healthMonitorId 삭제할 헬스 모니터의 ID
	@return ApiDeleteHealthMonitorRequest
*/
func (a *LoadBalancerTargetGroupAPIService) DeleteHealthMonitor(ctx context.Context, healthMonitorId string) ApiDeleteHealthMonitorRequest {
	return ApiDeleteHealthMonitorRequest{
		ApiService:      a,
		ctx:             ctx,
		healthMonitorId: healthMonitorId,
	}
}

// Execute executes the request
func (a *LoadBalancerTargetGroupAPIService) DeleteHealthMonitorExecute(r ApiDeleteHealthMonitorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.DeleteHealthMonitor")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/health-monitors/{health_monitor_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"health_monitor_id"+"}", url.PathEscape(parameterValueToString(r.healthMonitorId, "healthMonitorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTargetGroupRequest struct {
	ctx           context.Context
	ApiService    LoadBalancerTargetGroupAPI
	targetGroupId string
	xAuthToken    *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiDeleteTargetGroupRequest) XAuthToken(xAuthToken string) ApiDeleteTargetGroupRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiDeleteTargetGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTargetGroupExecute(r)
}

/*
DeleteTargetGroup Delete target group

지정한 로드 밸런서의 대상 그룹을 삭제합니다.

:::caution 주의
대상 그룹을 삭제하면 해당 그룹과 연결된 리스너 설정, 헬스 모니터 등도 영향을 받을 수 있으므로 삭제 전 구성을 반드시 확인해야 합니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetGroupId 삭제할 대상 그룹의 ID
	@return ApiDeleteTargetGroupRequest
*/
func (a *LoadBalancerTargetGroupAPIService) DeleteTargetGroup(ctx context.Context, targetGroupId string) ApiDeleteTargetGroupRequest {
	return ApiDeleteTargetGroupRequest{
		ApiService:    a,
		ctx:           ctx,
		targetGroupId: targetGroupId,
	}
}

// Execute executes the request
func (a *LoadBalancerTargetGroupAPIService) DeleteTargetGroupExecute(r ApiDeleteTargetGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.DeleteTargetGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups/{target_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target_group_id"+"}", url.PathEscape(parameterValueToString(r.targetGroupId, "targetGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetTargetGroupRequest struct {
	ctx           context.Context
	ApiService    LoadBalancerTargetGroupAPI
	targetGroupId string
	xAuthToken    *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiGetTargetGroupRequest) XAuthToken(xAuthToken string) ApiGetTargetGroupRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiGetTargetGroupRequest) Execute() (*TargetGroupResponseModel, *http.Response, error) {
	return r.ApiService.GetTargetGroupExecute(r)
}

/*
GetTargetGroup Get target group

지정한 대상 그룹 ID에 해당하는 로드 밸런서 대상 그룹의 상세 정보를 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetGroupId 조회할 대상 그룹 ID
	@return ApiGetTargetGroupRequest
*/
func (a *LoadBalancerTargetGroupAPIService) GetTargetGroup(ctx context.Context, targetGroupId string) ApiGetTargetGroupRequest {
	return ApiGetTargetGroupRequest{
		ApiService:    a,
		ctx:           ctx,
		targetGroupId: targetGroupId,
	}
}

// Execute executes the request
//
//	@return TargetGroupResponseModel
func (a *LoadBalancerTargetGroupAPIService) GetTargetGroupExecute(r ApiGetTargetGroupRequest) (*TargetGroupResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TargetGroupResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.GetTargetGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups/{target_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target_group_id"+"}", url.PathEscape(parameterValueToString(r.targetGroupId, "targetGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTargetGroupHealthCheckSubnetsRequest struct {
	ctx           context.Context
	ApiService    LoadBalancerTargetGroupAPI
	targetGroupId string
	xAuthToken    *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiGetTargetGroupHealthCheckSubnetsRequest) XAuthToken(xAuthToken string) ApiGetTargetGroupHealthCheckSubnetsRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiGetTargetGroupHealthCheckSubnetsRequest) Execute() (*ResponseHealthCheckSubnetsModel, *http.Response, error) {
	return r.ApiService.GetTargetGroupHealthCheckSubnetsExecute(r)
}

/*
GetTargetGroupHealthCheckSubnets Get target group health check subnets

대상 그룹의 헬스 체크에 사용되는 IP 목록을 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetGroupId 대상 그룹 ID
	@return ApiGetTargetGroupHealthCheckSubnetsRequest
*/
func (a *LoadBalancerTargetGroupAPIService) GetTargetGroupHealthCheckSubnets(ctx context.Context, targetGroupId string) ApiGetTargetGroupHealthCheckSubnetsRequest {
	return ApiGetTargetGroupHealthCheckSubnetsRequest{
		ApiService:    a,
		ctx:           ctx,
		targetGroupId: targetGroupId,
	}
}

// Execute executes the request
//
//	@return ResponseHealthCheckSubnetsModel
func (a *LoadBalancerTargetGroupAPIService) GetTargetGroupHealthCheckSubnetsExecute(r ApiGetTargetGroupHealthCheckSubnetsRequest) (*ResponseHealthCheckSubnetsModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseHealthCheckSubnetsModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.GetTargetGroupHealthCheckSubnets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups/{target_group_id}/health-check-subnets"
	localVarPath = strings.Replace(localVarPath, "{"+"target_group_id"+"}", url.PathEscape(parameterValueToString(r.targetGroupId, "targetGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTargetGroupHealthMonitorRequest struct {
	ctx             context.Context
	ApiService      LoadBalancerTargetGroupAPI
	healthMonitorId string
	xAuthToken      *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiGetTargetGroupHealthMonitorRequest) XAuthToken(xAuthToken string) ApiGetTargetGroupHealthMonitorRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiGetTargetGroupHealthMonitorRequest) Execute() (*BnsLoadBalancerV1ApiGetTargetGroupHealthMonitorModelResponseHealthMonitorModel, *http.Response, error) {
	return r.ApiService.GetTargetGroupHealthMonitorExecute(r)
}

/*
GetTargetGroupHealthMonitor Get target group health monitor

지정한 헬스 모니터 ID에 해당하는 대상 그룹 헬스 모니터의 상세 정보를 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param healthMonitorId 조회할 헬스 모니터 ID
	@return ApiGetTargetGroupHealthMonitorRequest
*/
func (a *LoadBalancerTargetGroupAPIService) GetTargetGroupHealthMonitor(ctx context.Context, healthMonitorId string) ApiGetTargetGroupHealthMonitorRequest {
	return ApiGetTargetGroupHealthMonitorRequest{
		ApiService:      a,
		ctx:             ctx,
		healthMonitorId: healthMonitorId,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiGetTargetGroupHealthMonitorModelResponseHealthMonitorModel
func (a *LoadBalancerTargetGroupAPIService) GetTargetGroupHealthMonitorExecute(r ApiGetTargetGroupHealthMonitorRequest) (*BnsLoadBalancerV1ApiGetTargetGroupHealthMonitorModelResponseHealthMonitorModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiGetTargetGroupHealthMonitorModelResponseHealthMonitorModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.GetTargetGroupHealthMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/health-monitors/{health_monitor_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"health_monitor_id"+"}", url.PathEscape(parameterValueToString(r.healthMonitorId, "healthMonitorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTargetGroupsRequest struct {
	ctx                   context.Context
	ApiService            LoadBalancerTargetGroupAPI
	xAuthToken            *string
	id                    *string
	name                  *string
	protocol              *TargetGroupProtocol
	availabilityZone      *AvailabilityZone
	loadBalancerAlgorithm *TargetGroupAlgorithm
	loadBalancerName      *string
	loadBalancerId        *string
	listenerProtocol      *Protocol
	vpcName               *string
	vpcId                 *string
	subnetName            *string
	subnetId              *string
	healthMonitorId       *string
	createdAt             *string
	updatedAt             *string
	sortKeys              *string
	sortDirs              *string
	limit                 *int32
	offset                *int32
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiListTargetGroupsRequest) XAuthToken(xAuthToken string) ApiListTargetGroupsRequest {
	r.xAuthToken = &xAuthToken
	return r
}

// 대상 그룹 ID
func (r ApiListTargetGroupsRequest) Id(id string) ApiListTargetGroupsRequest {
	r.id = &id
	return r
}

// 대상 그룹 이름
func (r ApiListTargetGroupsRequest) Name(name string) ApiListTargetGroupsRequest {
	r.name = &name
	return r
}

// 대상 그룹의 프로토콜 &lt;br/&gt; - &#x60;HTTP&#x60;: HTTP &lt;br/&gt; - &#x60;HTTPS&#x60;: HTTPS &lt;br/&gt; - &#x60;TCP&#x60;: TCP &lt;br/&gt; - &#x60;UDP&#x60;: UDP &lt;br/&gt; - &#x60;PROXY&#x60;: 프록시 프로토콜
func (r ApiListTargetGroupsRequest) Protocol(protocol TargetGroupProtocol) ApiListTargetGroupsRequest {
	r.protocol = &protocol
	return r
}

// 대상 그룹이 위치한 가용 영역
func (r ApiListTargetGroupsRequest) AvailabilityZone(availabilityZone AvailabilityZone) ApiListTargetGroupsRequest {
	r.availabilityZone = &availabilityZone
	return r
}

// 로드 밸런싱 알고리즘 &lt;br/&gt; - &#x60;ROUND_ROBIN&#x60;: 라운드 로빈 방식 &lt;br/&gt; - &#x60;LEAST_CONNECTIONS&#x60;: 최소 연결 방식 &lt;br/&gt; - &#x60;SOURCE_IP&#x60;: 소스 IP 기반 방식
func (r ApiListTargetGroupsRequest) LoadBalancerAlgorithm(loadBalancerAlgorithm TargetGroupAlgorithm) ApiListTargetGroupsRequest {
	r.loadBalancerAlgorithm = &loadBalancerAlgorithm
	return r
}

// 연결된 로드 밸런서 이름
func (r ApiListTargetGroupsRequest) LoadBalancerName(loadBalancerName string) ApiListTargetGroupsRequest {
	r.loadBalancerName = &loadBalancerName
	return r
}

// 연결된 로드 밸런서 ID
func (r ApiListTargetGroupsRequest) LoadBalancerId(loadBalancerId string) ApiListTargetGroupsRequest {
	r.loadBalancerId = &loadBalancerId
	return r
}

// 리스너 프로토콜 &lt;br/&gt; - &#x60;HTTP&#x60;: HTTP &lt;br/&gt; - &#x60;TCP&#x60;: TCP &lt;br/&gt; - &#x60;UDP&#x60;: UDP &lt;br/&gt; - &#x60;TERMINATED_HTTPS&#x60;: 로드 밸런서에서 SSL 종료 처리된 HTTPS
func (r ApiListTargetGroupsRequest) ListenerProtocol(listenerProtocol Protocol) ApiListTargetGroupsRequest {
	r.listenerProtocol = &listenerProtocol
	return r
}

// 대상 그룹이 속한 VPC 이름
func (r ApiListTargetGroupsRequest) VpcName(vpcName string) ApiListTargetGroupsRequest {
	r.vpcName = &vpcName
	return r
}

// 대상 그룹이 속한 VPC ID
func (r ApiListTargetGroupsRequest) VpcId(vpcId string) ApiListTargetGroupsRequest {
	r.vpcId = &vpcId
	return r
}

// 서브넷 이름
func (r ApiListTargetGroupsRequest) SubnetName(subnetName string) ApiListTargetGroupsRequest {
	r.subnetName = &subnetName
	return r
}

// 서브넷 ID
func (r ApiListTargetGroupsRequest) SubnetId(subnetId string) ApiListTargetGroupsRequest {
	r.subnetId = &subnetId
	return r
}

// 연결된 헬스 모니터 ID
func (r ApiListTargetGroupsRequest) HealthMonitorId(healthMonitorId string) ApiListTargetGroupsRequest {
	r.healthMonitorId = &healthMonitorId
	return r
}

// 리소스가 생성된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListTargetGroupsRequest) CreatedAt(createdAt string) ApiListTargetGroupsRequest {
	r.createdAt = &createdAt
	return r
}

// 리소스가 마지막으로 수정된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListTargetGroupsRequest) UpdatedAt(updatedAt string) ApiListTargetGroupsRequest {
	r.updatedAt = &updatedAt
	return r
}

// 정렬할 필드를 콤마(,)로 구분
func (r ApiListTargetGroupsRequest) SortKeys(sortKeys string) ApiListTargetGroupsRequest {
	r.sortKeys = &sortKeys
	return r
}

// 정렬 방향 (&#x60;asc&#x60;, &#x60;desc&#x60;)
func (r ApiListTargetGroupsRequest) SortDirs(sortDirs string) ApiListTargetGroupsRequest {
	r.sortDirs = &sortDirs
	return r
}

// 페이지당 최대 반환 항목 수
func (r ApiListTargetGroupsRequest) Limit(limit int32) ApiListTargetGroupsRequest {
	r.limit = &limit
	return r
}

// 조회 시작 위치
func (r ApiListTargetGroupsRequest) Offset(offset int32) ApiListTargetGroupsRequest {
	r.offset = &offset
	return r
}

func (r ApiListTargetGroupsRequest) Execute() (*TargetGroupListModel, *http.Response, error) {
	return r.ApiService.ListTargetGroupsExecute(r)
}

/*
ListTargetGroups List target groups

로드 밸런서에 등록된 대상 그룹 목록을 조회합니다.

:::caution 주의
대상 그룹은 로드 밸런서의 트래픽 분산 대상이므로, 구성 변경 시 서비스에 영향을 줄 수 있습니다. 프로비저닝 상태를 사전에 점검하세요.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListTargetGroupsRequest
*/
func (a *LoadBalancerTargetGroupAPIService) ListTargetGroups(ctx context.Context) ApiListTargetGroupsRequest {
	return ApiListTargetGroupsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return TargetGroupListModel
func (a *LoadBalancerTargetGroupAPIService) ListTargetGroupsExecute(r ApiListTargetGroupsRequest) (*TargetGroupListModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TargetGroupListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.ListTargetGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.protocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol", r.protocol, "form", "")
	}
	if r.availabilityZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availability_zone", r.availabilityZone, "form", "")
	}
	if r.loadBalancerAlgorithm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "load_balancer_algorithm", r.loadBalancerAlgorithm, "form", "")
	}
	if r.loadBalancerName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "load_balancer_name", r.loadBalancerName, "form", "")
	}
	if r.loadBalancerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "load_balancer_id", r.loadBalancerId, "form", "")
	}
	if r.listenerProtocol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "listener_protocol", r.listenerProtocol, "form", "")
	}
	if r.vpcName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vpc_name", r.vpcName, "form", "")
	}
	if r.vpcId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vpc_id", r.vpcId, "form", "")
	}
	if r.subnetName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subnet_name", r.subnetName, "form", "")
	}
	if r.subnetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subnet_id", r.subnetId, "form", "")
	}
	if r.healthMonitorId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "health_monitor_id", r.healthMonitorId, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	if r.sortKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_keys", r.sortKeys, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortKeys = &defaultValue
	}
	if r.sortDirs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dirs", r.sortDirs, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortDirs = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTargetsInTargetGroupRequest struct {
	ctx                context.Context
	ApiService         LoadBalancerTargetGroupAPI
	targetGroupId      string
	xAuthToken         *string
	ip                 *string
	protocolPort       *string
	weight             *string
	provisioningStatus *ProvisioningStatus
	operatingStatus    *LoadBalancerOperatingStatus
	instanceId         *string
	instanceName       *string
	vpcId              *string
	subnetId           *string
	subnetName         *string
	securityGroupName  *string
	createdAt          *string
	updatedAt          *string
	sortKeys           *string
	sortDirs           *string
	limit              *int32
	offset             *int32
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiListTargetsInTargetGroupRequest) XAuthToken(xAuthToken string) ApiListTargetsInTargetGroupRequest {
	r.xAuthToken = &xAuthToken
	return r
}

// 대상 인스턴스의 IP 주소
func (r ApiListTargetsInTargetGroupRequest) Ip(ip string) ApiListTargetsInTargetGroupRequest {
	r.ip = &ip
	return r
}

// 연결 포트 번호
func (r ApiListTargetsInTargetGroupRequest) ProtocolPort(protocolPort string) ApiListTargetsInTargetGroupRequest {
	r.protocolPort = &protocolPort
	return r
}

// 트래픽 분산 가중치
func (r ApiListTargetsInTargetGroupRequest) Weight(weight string) ApiListTargetsInTargetGroupRequest {
	r.weight = &weight
	return r
}

// 프로비저닝 상태 &lt;br/&gt; - &#x60;ACTIVE&#x60;: 활성 &lt;br/&gt; - &#x60;DELETED&#x60;: 삭제됨 &lt;br/&gt; - &#x60;ERROR&#x60;: 오류 &lt;br/&gt; - &#x60;PENDING_CREATE&#x60;: 생성 대기 중 &lt;br/&gt; - &#x60;PENDING_UPDATE&#x60;: 업데이트 대기 중 &lt;br/&gt; - &#x60;PENDING_DELETE&#x60;: 삭제 대기 중
func (r ApiListTargetsInTargetGroupRequest) ProvisioningStatus(provisioningStatus ProvisioningStatus) ApiListTargetsInTargetGroupRequest {
	r.provisioningStatus = &provisioningStatus
	return r
}

// 운영 상태 &lt;br/&gt; - &#x60;ONLINE&#x60;: 온라인 &lt;br/&gt; - &#x60;DRAINING&#x60;: 연결 종료 중 &lt;br/&gt; - &#x60;OFFLINE&#x60;: 오프라인 &lt;br/&gt; - &#x60;DEGRADED&#x60;: 성능 저하 &lt;br/&gt; - &#x60;ERROR&#x60;: 오류 &lt;br/&gt; - &#x60;NO_MONITOR&#x60;: 모니터링 없음
func (r ApiListTargetsInTargetGroupRequest) OperatingStatus(operatingStatus LoadBalancerOperatingStatus) ApiListTargetsInTargetGroupRequest {
	r.operatingStatus = &operatingStatus
	return r
}

// 인스턴스의 고유 ID
func (r ApiListTargetsInTargetGroupRequest) InstanceId(instanceId string) ApiListTargetsInTargetGroupRequest {
	r.instanceId = &instanceId
	return r
}

// 연결된 인스턴스 이름
func (r ApiListTargetsInTargetGroupRequest) InstanceName(instanceName string) ApiListTargetsInTargetGroupRequest {
	r.instanceName = &instanceName
	return r
}

// 대상 인스턴스의 VPC ID
func (r ApiListTargetsInTargetGroupRequest) VpcId(vpcId string) ApiListTargetsInTargetGroupRequest {
	r.vpcId = &vpcId
	return r
}

// 대상 인스턴스의 서브넷 ID
func (r ApiListTargetsInTargetGroupRequest) SubnetId(subnetId string) ApiListTargetsInTargetGroupRequest {
	r.subnetId = &subnetId
	return r
}

// 대상 인스턴스의 서브넷 이름
func (r ApiListTargetsInTargetGroupRequest) SubnetName(subnetName string) ApiListTargetsInTargetGroupRequest {
	r.subnetName = &subnetName
	return r
}

// 보안 그룹 이름
func (r ApiListTargetsInTargetGroupRequest) SecurityGroupName(securityGroupName string) ApiListTargetsInTargetGroupRequest {
	r.securityGroupName = &securityGroupName
	return r
}

// 리소스가 생성된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListTargetsInTargetGroupRequest) CreatedAt(createdAt string) ApiListTargetsInTargetGroupRequest {
	r.createdAt = &createdAt
	return r
}

// 리소스가 마지막으로 수정된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListTargetsInTargetGroupRequest) UpdatedAt(updatedAt string) ApiListTargetsInTargetGroupRequest {
	r.updatedAt = &updatedAt
	return r
}

// 정렬할 필드를 콤마(,)로 구분
func (r ApiListTargetsInTargetGroupRequest) SortKeys(sortKeys string) ApiListTargetsInTargetGroupRequest {
	r.sortKeys = &sortKeys
	return r
}

// 정렬 방향 (&#x60;asc&#x60;, &#x60;desc&#x60;)
func (r ApiListTargetsInTargetGroupRequest) SortDirs(sortDirs string) ApiListTargetsInTargetGroupRequest {
	r.sortDirs = &sortDirs
	return r
}

// 페이지당 최대 반환 항목 수
func (r ApiListTargetsInTargetGroupRequest) Limit(limit int32) ApiListTargetsInTargetGroupRequest {
	r.limit = &limit
	return r
}

// 조회 시작 위치
func (r ApiListTargetsInTargetGroupRequest) Offset(offset int32) ApiListTargetsInTargetGroupRequest {
	r.offset = &offset
	return r
}

func (r ApiListTargetsInTargetGroupRequest) Execute() (*TargetGroupMemberListModel, *http.Response, error) {
	return r.ApiService.ListTargetsInTargetGroupExecute(r)
}

/*
ListTargetsInTargetGroup List targets in target group

특정 로드 밸런서 대상 그룹에 포함된 대상(Target) 인스턴스의 목록을 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetGroupId 대상 그룹 ID
	@return ApiListTargetsInTargetGroupRequest
*/
func (a *LoadBalancerTargetGroupAPIService) ListTargetsInTargetGroup(ctx context.Context, targetGroupId string) ApiListTargetsInTargetGroupRequest {
	return ApiListTargetsInTargetGroupRequest{
		ApiService:    a,
		ctx:           ctx,
		targetGroupId: targetGroupId,
	}
}

// Execute executes the request
//
//	@return TargetGroupMemberListModel
func (a *LoadBalancerTargetGroupAPIService) ListTargetsInTargetGroupExecute(r ApiListTargetsInTargetGroupRequest) (*TargetGroupMemberListModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *TargetGroupMemberListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.ListTargetsInTargetGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups/{target_group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"target_group_id"+"}", url.PathEscape(parameterValueToString(r.targetGroupId, "targetGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	if r.ip != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ip", r.ip, "form", "")
	}
	if r.protocolPort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "protocol_port", r.protocolPort, "form", "")
	}
	if r.weight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "weight", r.weight, "form", "")
	}
	if r.provisioningStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provisioning_status", r.provisioningStatus, "form", "")
	}
	if r.operatingStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operating_status", r.operatingStatus, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_name", r.instanceName, "form", "")
	}
	if r.vpcId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vpc_id", r.vpcId, "form", "")
	}
	if r.subnetId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subnet_id", r.subnetId, "form", "")
	}
	if r.subnetName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subnet_name", r.subnetName, "form", "")
	}
	if r.securityGroupName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "security_group_name", r.securityGroupName, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	if r.sortKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_keys", r.sortKeys, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortKeys = &defaultValue
	}
	if r.sortDirs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dirs", r.sortDirs, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortDirs = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveTargetRequest struct {
	ctx           context.Context
	ApiService    LoadBalancerTargetGroupAPI
	targetGroupId string
	memberId      string
	xAuthToken    *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiRemoveTargetRequest) XAuthToken(xAuthToken string) ApiRemoveTargetRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiRemoveTargetRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveTargetExecute(r)
}

/*
RemoveTarget Remove target

로드 밸런서 대상 그룹에서 지정한 대상 인스턴스를 삭제합니다.
삭제된 대상은 더 이상 트래픽 분산 대상에 포함되지 않습니다.

:::info 안내
대상을 삭제하면 해당 인스턴스로의 트래픽 전달이 즉시 중단됩니다. 삭제 전 서비스 영향도를 충분히 고려하세요.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetGroupId 대상 그룹 ID
	@param memberId 삭제할 대상 인스턴스의 ID
	@return ApiRemoveTargetRequest
*/
func (a *LoadBalancerTargetGroupAPIService) RemoveTarget(ctx context.Context, targetGroupId string, memberId string) ApiRemoveTargetRequest {
	return ApiRemoveTargetRequest{
		ApiService:    a,
		ctx:           ctx,
		targetGroupId: targetGroupId,
		memberId:      memberId,
	}
}

// Execute executes the request
func (a *LoadBalancerTargetGroupAPIService) RemoveTargetExecute(r ApiRemoveTargetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.RemoveTarget")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups/{target_group_id}/members/{member_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target_group_id"+"}", url.PathEscape(parameterValueToString(r.targetGroupId, "targetGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"member_id"+"}", url.PathEscape(parameterValueToString(r.memberId, "memberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateHealthMonitorRequest struct {
	ctx                     context.Context
	ApiService              LoadBalancerTargetGroupAPI
	healthMonitorId         string
	xAuthToken              *string
	bodyUpdateHealthMonitor *BodyUpdateHealthMonitor
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUpdateHealthMonitorRequest) XAuthToken(xAuthToken string) ApiUpdateHealthMonitorRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUpdateHealthMonitorRequest) BodyUpdateHealthMonitor(bodyUpdateHealthMonitor BodyUpdateHealthMonitor) ApiUpdateHealthMonitorRequest {
	r.bodyUpdateHealthMonitor = &bodyUpdateHealthMonitor
	return r
}

func (r ApiUpdateHealthMonitorRequest) Execute() (*BnsLoadBalancerV1ApiUpdateHealthMonitorModelResponseHealthMonitorModel, *http.Response, error) {
	return r.ApiService.UpdateHealthMonitorExecute(r)
}

/*
UpdateHealthMonitor Update health monitor

지정한 헬스 모니터의 설정을 수정합니다.

:::info 안내
- 지원하지 않는 `http_method` 또는 부정확한 `expected_codes` 값을 설정할 경우, 트래픽 라우팅 오류가 발생할 수 있습니다.
- 설정 변경은 대상 그룹 전체에 영향을 주며, 적용 즉시 다음 헬스 체크 주기부터 반영됩니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param healthMonitorId 수정 대상 헬스 모니터의 ID
	@return ApiUpdateHealthMonitorRequest
*/
func (a *LoadBalancerTargetGroupAPIService) UpdateHealthMonitor(ctx context.Context, healthMonitorId string) ApiUpdateHealthMonitorRequest {
	return ApiUpdateHealthMonitorRequest{
		ApiService:      a,
		ctx:             ctx,
		healthMonitorId: healthMonitorId,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiUpdateHealthMonitorModelResponseHealthMonitorModel
func (a *LoadBalancerTargetGroupAPIService) UpdateHealthMonitorExecute(r ApiUpdateHealthMonitorRequest) (*BnsLoadBalancerV1ApiUpdateHealthMonitorModelResponseHealthMonitorModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiUpdateHealthMonitorModelResponseHealthMonitorModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.UpdateHealthMonitor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/health-monitors/{health_monitor_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"health_monitor_id"+"}", url.PathEscape(parameterValueToString(r.healthMonitorId, "healthMonitorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyUpdateHealthMonitor == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateHealthMonitor is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyUpdateHealthMonitor
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTargetRequest struct {
	ctx              context.Context
	ApiService       LoadBalancerTargetGroupAPI
	targetGroupId    string
	memberId         string
	xAuthToken       *string
	bodyUpdateTarget *BodyUpdateTarget
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUpdateTargetRequest) XAuthToken(xAuthToken string) ApiUpdateTargetRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUpdateTargetRequest) BodyUpdateTarget(bodyUpdateTarget BodyUpdateTarget) ApiUpdateTargetRequest {
	r.bodyUpdateTarget = &bodyUpdateTarget
	return r
}

func (r ApiUpdateTargetRequest) Execute() (*BnsLoadBalancerV1ApiUpdateTargetModelResponseTargetGroupMemberModel, *http.Response, error) {
	return r.ApiService.UpdateTargetExecute(r)
}

/*
UpdateTarget Update target

로드 밸런서 대상 그룹의 특정 대상 인스턴스 정보를 수정합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetGroupId 대상 그룹 ID
	@param memberId 수정할 대상 인스턴스의 ID
	@return ApiUpdateTargetRequest
*/
func (a *LoadBalancerTargetGroupAPIService) UpdateTarget(ctx context.Context, targetGroupId string, memberId string) ApiUpdateTargetRequest {
	return ApiUpdateTargetRequest{
		ApiService:    a,
		ctx:           ctx,
		targetGroupId: targetGroupId,
		memberId:      memberId,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiUpdateTargetModelResponseTargetGroupMemberModel
func (a *LoadBalancerTargetGroupAPIService) UpdateTargetExecute(r ApiUpdateTargetRequest) (*BnsLoadBalancerV1ApiUpdateTargetModelResponseTargetGroupMemberModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiUpdateTargetModelResponseTargetGroupMemberModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.UpdateTarget")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups/{target_group_id}/members/{member_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target_group_id"+"}", url.PathEscape(parameterValueToString(r.targetGroupId, "targetGroupId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"member_id"+"}", url.PathEscape(parameterValueToString(r.memberId, "memberId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyUpdateTarget == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateTarget is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyUpdateTarget
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTargetGroupRequest struct {
	ctx                   context.Context
	ApiService            LoadBalancerTargetGroupAPI
	targetGroupId         string
	xAuthToken            *string
	bodyUpdateTargetGroup *BodyUpdateTargetGroup
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUpdateTargetGroupRequest) XAuthToken(xAuthToken string) ApiUpdateTargetGroupRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUpdateTargetGroupRequest) BodyUpdateTargetGroup(bodyUpdateTargetGroup BodyUpdateTargetGroup) ApiUpdateTargetGroupRequest {
	r.bodyUpdateTargetGroup = &bodyUpdateTargetGroup
	return r
}

func (r ApiUpdateTargetGroupRequest) Execute() (*BnsLoadBalancerV1ApiUpdateTargetGroupModelResponseTargetGroupModel, *http.Response, error) {
	return r.ApiService.UpdateTargetGroupExecute(r)
}

/*
UpdateTargetGroup Update target group

로드 밸런서에 연결된 대상 그룹의 정보를 수정합니다.

:::info 안내
- 세션은 대상 그룹과 리스너가 연결된 경우에만 설정할 수 있습니다.
- 세션은 리스너 프로토콜과 대상 그룹 프로토콜 조합이 `HTTP-HTTP`, `TCP-TCP`, `UDP-UDP`인 경우에만 설정할 수 있습니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetGroupId 수정할 대상 그룹의 ID
	@return ApiUpdateTargetGroupRequest
*/
func (a *LoadBalancerTargetGroupAPIService) UpdateTargetGroup(ctx context.Context, targetGroupId string) ApiUpdateTargetGroupRequest {
	return ApiUpdateTargetGroupRequest{
		ApiService:    a,
		ctx:           ctx,
		targetGroupId: targetGroupId,
	}
}

// Execute executes the request
//
//	@return BnsLoadBalancerV1ApiUpdateTargetGroupModelResponseTargetGroupModel
func (a *LoadBalancerTargetGroupAPIService) UpdateTargetGroupExecute(r ApiUpdateTargetGroupRequest) (*BnsLoadBalancerV1ApiUpdateTargetGroupModelResponseTargetGroupModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsLoadBalancerV1ApiUpdateTargetGroupModelResponseTargetGroupModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.UpdateTargetGroup")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups/{target_group_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"target_group_id"+"}", url.PathEscape(parameterValueToString(r.targetGroupId, "targetGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyUpdateTargetGroup == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateTargetGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyUpdateTargetGroup
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTargetsRequest struct {
	ctx               context.Context
	ApiService        LoadBalancerTargetGroupAPI
	targetGroupId     string
	xAuthToken        *string
	bodyUpdateTargets *BodyUpdateTargets
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUpdateTargetsRequest) XAuthToken(xAuthToken string) ApiUpdateTargetsRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUpdateTargetsRequest) BodyUpdateTargets(bodyUpdateTargets BodyUpdateTargets) ApiUpdateTargetsRequest {
	r.bodyUpdateTargets = &bodyUpdateTargets
	return r
}

func (r ApiUpdateTargetsRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.UpdateTargetsExecute(r)
}

/*
UpdateTargets Update targets

로드 밸런서 대상 그룹의 여러 대상 인스턴스 정보를 일괄 수정합니다. <br/>
기존 대상 인스턴스를 수정/삭제하거나, 새로운 대상 인스턴스를 추가할 수 있습니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param targetGroupId 수정할 대상 인스턴스가 속한 대상 그룹의 ID
	@return ApiUpdateTargetsRequest
*/
func (a *LoadBalancerTargetGroupAPIService) UpdateTargets(ctx context.Context, targetGroupId string) ApiUpdateTargetsRequest {
	return ApiUpdateTargetsRequest{
		ApiService:    a,
		ctx:           ctx,
		targetGroupId: targetGroupId,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *LoadBalancerTargetGroupAPIService) UpdateTargetsExecute(r ApiUpdateTargetsRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LoadBalancerTargetGroupAPIService.UpdateTargets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/load-balancers/target-groups/{target_group_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"target_group_id"+"}", url.PathEscape(parameterValueToString(r.targetGroupId, "targetGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyUpdateTargets == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateTargets is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyUpdateTargets
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
