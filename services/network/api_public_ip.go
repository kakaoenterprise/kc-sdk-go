/*
Beyond Networking Service(BNS) Public IP/Security Group API

Public IP/Security Group API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package network

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type PublicIPAPI interface {

	/*
		AssociatePublicIp Associate public IP

		퍼블릭 IP를 지정된 네트워크 인터페이스에 연결합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param publicIpId 연결할 퍼블릭 IP의 ID
		@param networkInterfaceId 퍼블릭 IP를 연결할 대상 네트워크 인터페이스의 ID
		@return ApiAssociatePublicIpRequest
	*/
	AssociatePublicIp(ctx context.Context, publicIpId string, networkInterfaceId string) ApiAssociatePublicIpRequest

	// AssociatePublicIpExecute executes the request
	//  @return BnsNetworkV1ApiAssociatePublicIpModelResponsePublicIpModel
	AssociatePublicIpExecute(r ApiAssociatePublicIpRequest) (*BnsNetworkV1ApiAssociatePublicIpModelResponsePublicIpModel, *http.Response, error)

	/*
		CreatePublicIp Create public IP

		신규 퍼블릭 IP를 생성합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreatePublicIpRequest
	*/
	CreatePublicIp(ctx context.Context) ApiCreatePublicIpRequest

	// CreatePublicIpExecute executes the request
	//  @return BnsNetworkV1ApiCreatePublicIpModelResponsePublicIpModel
	CreatePublicIpExecute(r ApiCreatePublicIpRequest) (*BnsNetworkV1ApiCreatePublicIpModelResponsePublicIpModel, *http.Response, error)

	/*
		DeletePublicIp Delete public IP

		지정한 퍼블릭 IP를 삭제합니다.
	퍼블릭 IP는 할당 해제된 상태(available)에서만 삭제할 수 있습니다.


	:::caution 주의
	- 삭제한 퍼블릭 IP는 복구할 수 없습니다.
	- 현재 인스턴스 또는 네트워크 인터페이스에 연결된 IP는 삭제할 수 없습니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param publicIpId 삭제할 퍼블릭 IP ID
		@return ApiDeletePublicIpRequest
	*/
	DeletePublicIp(ctx context.Context, publicIpId string) ApiDeletePublicIpRequest

	// DeletePublicIpExecute executes the request
	DeletePublicIpExecute(r ApiDeletePublicIpRequest) (*http.Response, error)

	/*
		DisassociatePublicIp Disassociate public IP

		지정된 퍼블릭 IP와 네트워크 인터페이스 간의 연결을 해제합니다.


	:::caution 주의
	이 작업은 서비스의 외부 통신 경로를 제거하므로, 해당 IP를 사용하는 인프라나 서비스에 영향을 줄 수 있습니다. <br/>
	작업 전 네트워크 구성과 외부 의존성 여부를 반드시 확인하시기 바랍니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param publicIpId 연결 해제할 퍼블릭 IP의 ID
		@param networkInterfaceId 연결 해제 대상 네트워크 인터페이스의 ID
		@return ApiDisassociatePublicIpRequest
	*/
	DisassociatePublicIp(ctx context.Context, publicIpId string, networkInterfaceId string) ApiDisassociatePublicIpRequest

	// DisassociatePublicIpExecute executes the request
	//  @return BnsNetworkV1ApiDisassociatePublicIpModelResponsePublicIpModel
	DisassociatePublicIpExecute(r ApiDisassociatePublicIpRequest) (*BnsNetworkV1ApiDisassociatePublicIpModelResponsePublicIpModel, *http.Response, error)

	/*
		GetPublicIp Get public IP

		지정된 퍼블릭 IP의 상세 정보를 조회합니다.
	조회 결과에는 IP 상태, 설명, 연결된 네트워크 인터페이스 등의 정보가 포함됩니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param publicIpId 조회할 퍼블릭 IP ID
		@return ApiGetPublicIpRequest
	*/
	GetPublicIp(ctx context.Context, publicIpId string) ApiGetPublicIpRequest

	// GetPublicIpExecute executes the request
	//  @return BnsNetworkV1ApiGetPublicIpModelResponsePublicIpModel
	GetPublicIpExecute(r ApiGetPublicIpRequest) (*BnsNetworkV1ApiGetPublicIpModelResponsePublicIpModel, *http.Response, error)

	/*
		ListPublicIps List public IPs

		프로젝트에 생성된 퍼블릭 IP 목록을 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListPublicIpsRequest
	*/
	ListPublicIps(ctx context.Context) ApiListPublicIpsRequest

	// ListPublicIpsExecute executes the request
	//  @return PublicIpListModel
	ListPublicIpsExecute(r ApiListPublicIpsRequest) (*PublicIpListModel, *http.Response, error)

	/*
		UpdatePublicIp Update public IP

		퍼블릭 IP에 대한 설명을 수정합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param publicIpId 퍼블릭 IP의 고유 ID
		@return ApiUpdatePublicIpRequest
	*/
	UpdatePublicIp(ctx context.Context, publicIpId string) ApiUpdatePublicIpRequest

	// UpdatePublicIpExecute executes the request
	//  @return BnsNetworkV1ApiUpdatePublicIpModelResponsePublicIpModel
	UpdatePublicIpExecute(r ApiUpdatePublicIpRequest) (*BnsNetworkV1ApiUpdatePublicIpModelResponsePublicIpModel, *http.Response, error)
}

// PublicIPAPIService PublicIPAPI service
type PublicIPAPIService service

type ApiAssociatePublicIpRequest struct {
	ctx                context.Context
	ApiService         PublicIPAPI
	publicIpId         string
	networkInterfaceId string
	xAuthToken         *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiAssociatePublicIpRequest) XAuthToken(xAuthToken string) ApiAssociatePublicIpRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiAssociatePublicIpRequest) Execute() (*BnsNetworkV1ApiAssociatePublicIpModelResponsePublicIpModel, *http.Response, error) {
	return r.ApiService.AssociatePublicIpExecute(r)
}

/*
AssociatePublicIp Associate public IP

퍼블릭 IP를 지정된 네트워크 인터페이스에 연결합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param publicIpId 연결할 퍼블릭 IP의 ID
	@param networkInterfaceId 퍼블릭 IP를 연결할 대상 네트워크 인터페이스의 ID
	@return ApiAssociatePublicIpRequest
*/
func (a *PublicIPAPIService) AssociatePublicIp(ctx context.Context, publicIpId string, networkInterfaceId string) ApiAssociatePublicIpRequest {
	return ApiAssociatePublicIpRequest{
		ApiService:         a,
		ctx:                ctx,
		publicIpId:         publicIpId,
		networkInterfaceId: networkInterfaceId,
	}
}

// Execute executes the request
//
//	@return BnsNetworkV1ApiAssociatePublicIpModelResponsePublicIpModel
func (a *PublicIPAPIService) AssociatePublicIpExecute(r ApiAssociatePublicIpRequest) (*BnsNetworkV1ApiAssociatePublicIpModelResponsePublicIpModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsNetworkV1ApiAssociatePublicIpModelResponsePublicIpModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicIPAPIService.AssociatePublicIp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/public-ips/{public_ip_id}/network-interfaces/{network_interface_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"public_ip_id"+"}", url.PathEscape(parameterValueToString(r.publicIpId, "publicIpId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"network_interface_id"+"}", url.PathEscape(parameterValueToString(r.networkInterfaceId, "networkInterfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatePublicIpRequest struct {
	ctx                context.Context
	ApiService         PublicIPAPI
	xAuthToken         *string
	bodyCreatePublicIp *BodyCreatePublicIp
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiCreatePublicIpRequest) XAuthToken(xAuthToken string) ApiCreatePublicIpRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiCreatePublicIpRequest) BodyCreatePublicIp(bodyCreatePublicIp BodyCreatePublicIp) ApiCreatePublicIpRequest {
	r.bodyCreatePublicIp = &bodyCreatePublicIp
	return r
}

func (r ApiCreatePublicIpRequest) Execute() (*BnsNetworkV1ApiCreatePublicIpModelResponsePublicIpModel, *http.Response, error) {
	return r.ApiService.CreatePublicIpExecute(r)
}

/*
CreatePublicIp Create public IP

신규 퍼블릭 IP를 생성합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreatePublicIpRequest
*/
func (a *PublicIPAPIService) CreatePublicIp(ctx context.Context) ApiCreatePublicIpRequest {
	return ApiCreatePublicIpRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BnsNetworkV1ApiCreatePublicIpModelResponsePublicIpModel
func (a *PublicIPAPIService) CreatePublicIpExecute(r ApiCreatePublicIpRequest) (*BnsNetworkV1ApiCreatePublicIpModelResponsePublicIpModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsNetworkV1ApiCreatePublicIpModelResponsePublicIpModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicIPAPIService.CreatePublicIp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/public-ips"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyCreatePublicIp == nil {
		return localVarReturnValue, nil, reportError("bodyCreatePublicIp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyCreatePublicIp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePublicIpRequest struct {
	ctx        context.Context
	ApiService PublicIPAPI
	publicIpId string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiDeletePublicIpRequest) XAuthToken(xAuthToken string) ApiDeletePublicIpRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiDeletePublicIpRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePublicIpExecute(r)
}

/*
DeletePublicIp Delete public IP

지정한 퍼블릭 IP를 삭제합니다.
퍼블릭 IP는 할당 해제된 상태(available)에서만 삭제할 수 있습니다.

:::caution 주의
- 삭제한 퍼블릭 IP는 복구할 수 없습니다.
- 현재 인스턴스 또는 네트워크 인터페이스에 연결된 IP는 삭제할 수 없습니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param publicIpId 삭제할 퍼블릭 IP ID
	@return ApiDeletePublicIpRequest
*/
func (a *PublicIPAPIService) DeletePublicIp(ctx context.Context, publicIpId string) ApiDeletePublicIpRequest {
	return ApiDeletePublicIpRequest{
		ApiService: a,
		ctx:        ctx,
		publicIpId: publicIpId,
	}
}

// Execute executes the request
func (a *PublicIPAPIService) DeletePublicIpExecute(r ApiDeletePublicIpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicIPAPIService.DeletePublicIp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/public-ips/{public_ip_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"public_ip_id"+"}", url.PathEscape(parameterValueToString(r.publicIpId, "publicIpId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisassociatePublicIpRequest struct {
	ctx                context.Context
	ApiService         PublicIPAPI
	publicIpId         string
	networkInterfaceId string
	xAuthToken         *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiDisassociatePublicIpRequest) XAuthToken(xAuthToken string) ApiDisassociatePublicIpRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiDisassociatePublicIpRequest) Execute() (*BnsNetworkV1ApiDisassociatePublicIpModelResponsePublicIpModel, *http.Response, error) {
	return r.ApiService.DisassociatePublicIpExecute(r)
}

/*
DisassociatePublicIp Disassociate public IP

지정된 퍼블릭 IP와 네트워크 인터페이스 간의 연결을 해제합니다.

:::caution 주의
이 작업은 서비스의 외부 통신 경로를 제거하므로, 해당 IP를 사용하는 인프라나 서비스에 영향을 줄 수 있습니다. <br/>
작업 전 네트워크 구성과 외부 의존성 여부를 반드시 확인하시기 바랍니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param publicIpId 연결 해제할 퍼블릭 IP의 ID
	@param networkInterfaceId 연결 해제 대상 네트워크 인터페이스의 ID
	@return ApiDisassociatePublicIpRequest
*/
func (a *PublicIPAPIService) DisassociatePublicIp(ctx context.Context, publicIpId string, networkInterfaceId string) ApiDisassociatePublicIpRequest {
	return ApiDisassociatePublicIpRequest{
		ApiService:         a,
		ctx:                ctx,
		publicIpId:         publicIpId,
		networkInterfaceId: networkInterfaceId,
	}
}

// Execute executes the request
//
//	@return BnsNetworkV1ApiDisassociatePublicIpModelResponsePublicIpModel
func (a *PublicIPAPIService) DisassociatePublicIpExecute(r ApiDisassociatePublicIpRequest) (*BnsNetworkV1ApiDisassociatePublicIpModelResponsePublicIpModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsNetworkV1ApiDisassociatePublicIpModelResponsePublicIpModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicIPAPIService.DisassociatePublicIp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/public-ips/{public_ip_id}/network-interfaces/{network_interface_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"public_ip_id"+"}", url.PathEscape(parameterValueToString(r.publicIpId, "publicIpId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"network_interface_id"+"}", url.PathEscape(parameterValueToString(r.networkInterfaceId, "networkInterfaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPublicIpRequest struct {
	ctx        context.Context
	ApiService PublicIPAPI
	publicIpId string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiGetPublicIpRequest) XAuthToken(xAuthToken string) ApiGetPublicIpRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiGetPublicIpRequest) Execute() (*BnsNetworkV1ApiGetPublicIpModelResponsePublicIpModel, *http.Response, error) {
	return r.ApiService.GetPublicIpExecute(r)
}

/*
GetPublicIp Get public IP

지정된 퍼블릭 IP의 상세 정보를 조회합니다.
조회 결과에는 IP 상태, 설명, 연결된 네트워크 인터페이스 등의 정보가 포함됩니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param publicIpId 조회할 퍼블릭 IP ID
	@return ApiGetPublicIpRequest
*/
func (a *PublicIPAPIService) GetPublicIp(ctx context.Context, publicIpId string) ApiGetPublicIpRequest {
	return ApiGetPublicIpRequest{
		ApiService: a,
		ctx:        ctx,
		publicIpId: publicIpId,
	}
}

// Execute executes the request
//
//	@return BnsNetworkV1ApiGetPublicIpModelResponsePublicIpModel
func (a *PublicIPAPIService) GetPublicIpExecute(r ApiGetPublicIpRequest) (*BnsNetworkV1ApiGetPublicIpModelResponsePublicIpModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsNetworkV1ApiGetPublicIpModelResponsePublicIpModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicIPAPIService.GetPublicIp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/public-ips/{public_ip_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"public_ip_id"+"}", url.PathEscape(parameterValueToString(r.publicIpId, "publicIpId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPublicIpsRequest struct {
	ctx                 context.Context
	ApiService          PublicIPAPI
	xAuthToken          *string
	id                  *string
	status              *PublicIpStatus
	publicIp            *string
	relatedResourceId   *string
	relatedResourceName *string
	createdAt           *string
	updatedAt           *string
	sortKeys            *string
	sortDirs            *string
	limit               *int32
	offset              *int32
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiListPublicIpsRequest) XAuthToken(xAuthToken string) ApiListPublicIpsRequest {
	r.xAuthToken = &xAuthToken
	return r
}

// 퍼블릭 IP의 고유 ID
func (r ApiListPublicIpsRequest) Id(id string) ApiListPublicIpsRequest {
	r.id = &id
	return r
}

// 상태 &lt;br/&gt; - &#x60;available&#x60;: 사용 가능 &lt;br/&gt; - &#x60;in_use&#x60;: 사용 중 &lt;br/&gt; - &#x60;attaching&#x60;: 연결 중
func (r ApiListPublicIpsRequest) Status(status PublicIpStatus) ApiListPublicIpsRequest {
	r.status = &status
	return r
}

// 퍼블릭 IP 주소
func (r ApiListPublicIpsRequest) PublicIp(publicIp string) ApiListPublicIpsRequest {
	r.publicIp = &publicIp
	return r
}

// 퍼블릭 IP가 연결된 리소스 ID (예: 네트워크 인터페이스 ID 등)
func (r ApiListPublicIpsRequest) RelatedResourceId(relatedResourceId string) ApiListPublicIpsRequest {
	r.relatedResourceId = &relatedResourceId
	return r
}

// 퍼블릭 IP가 연결된 리소스 이름 (예: 네트워크 인터페이스 이름 등)
func (r ApiListPublicIpsRequest) RelatedResourceName(relatedResourceName string) ApiListPublicIpsRequest {
	r.relatedResourceName = &relatedResourceName
	return r
}

// 리소스가 생성된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListPublicIpsRequest) CreatedAt(createdAt string) ApiListPublicIpsRequest {
	r.createdAt = &createdAt
	return r
}

// 리소스가 마지막으로 수정된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListPublicIpsRequest) UpdatedAt(updatedAt string) ApiListPublicIpsRequest {
	r.updatedAt = &updatedAt
	return r
}

// 정렬할 필드를 콤마(,)로 구분
func (r ApiListPublicIpsRequest) SortKeys(sortKeys string) ApiListPublicIpsRequest {
	r.sortKeys = &sortKeys
	return r
}

// 정렬 방향 (&#x60;asc&#x60;, &#x60;desc&#x60;)
func (r ApiListPublicIpsRequest) SortDirs(sortDirs string) ApiListPublicIpsRequest {
	r.sortDirs = &sortDirs
	return r
}

// 페이지당 최대 반환 항목 수
func (r ApiListPublicIpsRequest) Limit(limit int32) ApiListPublicIpsRequest {
	r.limit = &limit
	return r
}

// 조회 시작 위치
func (r ApiListPublicIpsRequest) Offset(offset int32) ApiListPublicIpsRequest {
	r.offset = &offset
	return r
}

func (r ApiListPublicIpsRequest) Execute() (*PublicIpListModel, *http.Response, error) {
	return r.ApiService.ListPublicIpsExecute(r)
}

/*
ListPublicIps List public IPs

프로젝트에 생성된 퍼블릭 IP 목록을 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListPublicIpsRequest
*/
func (a *PublicIPAPIService) ListPublicIps(ctx context.Context) ApiListPublicIpsRequest {
	return ApiListPublicIpsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return PublicIpListModel
func (a *PublicIPAPIService) ListPublicIpsExecute(r ApiListPublicIpsRequest) (*PublicIpListModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *PublicIpListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicIPAPIService.ListPublicIps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/public-ips"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.publicIp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "public_ip", r.publicIp, "form", "")
	}
	if r.relatedResourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "related_resource_id", r.relatedResourceId, "form", "")
	}
	if r.relatedResourceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "related_resource_name", r.relatedResourceName, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	if r.sortKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_keys", r.sortKeys, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortKeys = &defaultValue
	}
	if r.sortDirs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dirs", r.sortDirs, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortDirs = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePublicIpRequest struct {
	ctx                context.Context
	ApiService         PublicIPAPI
	publicIpId         string
	xAuthToken         *string
	bodyUpdatePublicIp *BodyUpdatePublicIp
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUpdatePublicIpRequest) XAuthToken(xAuthToken string) ApiUpdatePublicIpRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUpdatePublicIpRequest) BodyUpdatePublicIp(bodyUpdatePublicIp BodyUpdatePublicIp) ApiUpdatePublicIpRequest {
	r.bodyUpdatePublicIp = &bodyUpdatePublicIp
	return r
}

func (r ApiUpdatePublicIpRequest) Execute() (*BnsNetworkV1ApiUpdatePublicIpModelResponsePublicIpModel, *http.Response, error) {
	return r.ApiService.UpdatePublicIpExecute(r)
}

/*
UpdatePublicIp Update public IP

퍼블릭 IP에 대한 설명을 수정합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param publicIpId 퍼블릭 IP의 고유 ID
	@return ApiUpdatePublicIpRequest
*/
func (a *PublicIPAPIService) UpdatePublicIp(ctx context.Context, publicIpId string) ApiUpdatePublicIpRequest {
	return ApiUpdatePublicIpRequest{
		ApiService: a,
		ctx:        ctx,
		publicIpId: publicIpId,
	}
}

// Execute executes the request
//
//	@return BnsNetworkV1ApiUpdatePublicIpModelResponsePublicIpModel
func (a *PublicIPAPIService) UpdatePublicIpExecute(r ApiUpdatePublicIpRequest) (*BnsNetworkV1ApiUpdatePublicIpModelResponsePublicIpModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsNetworkV1ApiUpdatePublicIpModelResponsePublicIpModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicIPAPIService.UpdatePublicIp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/public-ips/{public_ip_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"public_ip_id"+"}", url.PathEscape(parameterValueToString(r.publicIpId, "publicIpId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyUpdatePublicIp == nil {
		return localVarReturnValue, nil, reportError("bodyUpdatePublicIp is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyUpdatePublicIp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
