/*
bns-tgw API

bns-tgw API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package tgw

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type TgwsAPI interface {

	/*
		CreateTransitGateway Create transit gateway

		Transit Gateway를 생성합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateTransitGatewayRequest
	*/
	CreateTransitGateway(ctx context.Context) ApiCreateTransitGatewayRequest

	// CreateTransitGatewayExecute executes the request
	//  @return BnsTgwV1ApiCreateTransitGatewayModelCreateTgwResponseModel
	CreateTransitGatewayExecute(r ApiCreateTransitGatewayRequest) (*BnsTgwV1ApiCreateTransitGatewayModelCreateTgwResponseModel, *http.Response, error)

	/*
		DeleteTransitGateway Delete transit gateway

		지정한 Transit Gateway를 삭제합니다.<br/>
	Transit Gateway 삭제 시 연결된 모든 Attachment, 라우팅 테이블, Association 등의 종속 리소스가 함께 해제되며, 삭제된 Transit Gateway는 복구할 수 없습니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param tgwId 삭제할 Transit Gateway ID
		@return ApiDeleteTransitGatewayRequest
	*/
	DeleteTransitGateway(ctx context.Context, tgwId string) ApiDeleteTransitGatewayRequest

	// DeleteTransitGatewayExecute executes the request
	DeleteTransitGatewayExecute(r ApiDeleteTransitGatewayRequest) (*http.Response, error)

	/*
		GetTransitGateway Get transit gateway

		Transit Gateway 상세 정보를 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param tgwId 조회할 Transit Gateway ID
		@return ApiGetTransitGatewayRequest
	*/
	GetTransitGateway(ctx context.Context, tgwId string) ApiGetTransitGatewayRequest

	// GetTransitGatewayExecute executes the request
	//  @return GetTgwResponseModel
	GetTransitGatewayExecute(r ApiGetTransitGatewayRequest) (*GetTgwResponseModel, *http.Response, error)

	/*
		ListTgwSharedProjects List TGW shared projects

		지정한 Transit Gateway ID에 대해 공유된 프로젝트 목록을 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param tgwId 조회할 Transit Gateway ID
		@return ApiListTgwSharedProjectsRequest
	*/
	ListTgwSharedProjects(ctx context.Context, tgwId string) ApiListTgwSharedProjectsRequest

	// ListTgwSharedProjectsExecute executes the request
	//  @return GetTgwProjectsResponseModel
	ListTgwSharedProjectsExecute(r ApiListTgwSharedProjectsRequest) (*GetTgwProjectsResponseModel, *http.Response, error)

	/*
		ListTransitGateways List transit gateways

		Transit Gateway 목록을 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListTransitGatewaysRequest
	*/
	ListTransitGateways(ctx context.Context) ApiListTransitGatewaysRequest

	// ListTransitGatewaysExecute executes the request
	//  @return GetTgwsResponseModel
	ListTransitGatewaysExecute(r ApiListTransitGatewaysRequest) (*GetTgwsResponseModel, *http.Response, error)

	/*
		ShareTransitGateway Share transit gateway

		지정한 Transit Gateway를 다른 프로젝트에 공유합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param tgwId 공유할 Transit Gateway ID
		@param targetProjectId 공유 대상 프로젝트 ID
		@return ApiShareTransitGatewayRequest
	*/
	ShareTransitGateway(ctx context.Context, tgwId string, targetProjectId string) ApiShareTransitGatewayRequest

	// ShareTransitGatewayExecute executes the request
	//  @return interface{}
	ShareTransitGatewayExecute(r ApiShareTransitGatewayRequest) (interface{}, *http.Response, error)

	/*
		UnshareTransitGateway Unshare transit gateway

		지정한 Transit Gateway의 공유를 해제하여, 해당 프로젝트에서 사용하지 않도록 합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param tgwId 공유 해제할 Transit Gateway ID
		@param targetProjectId 공유 해제 대상 프로젝트 ID
		@return ApiUnshareTransitGatewayRequest
	*/
	UnshareTransitGateway(ctx context.Context, tgwId string, targetProjectId string) ApiUnshareTransitGatewayRequest

	// UnshareTransitGatewayExecute executes the request
	UnshareTransitGatewayExecute(r ApiUnshareTransitGatewayRequest) (*http.Response, error)

	/*
		UpdateTransitGateway Update transit gateway

		Transit Gateway 설정을 수정합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param tgwId 수정할 Transit Gateway ID
		@return ApiUpdateTransitGatewayRequest
	*/
	UpdateTransitGateway(ctx context.Context, tgwId string) ApiUpdateTransitGatewayRequest

	// UpdateTransitGatewayExecute executes the request
	//  @return BnsTgwV1ApiUpdateTransitGatewayModelCreateTgwResponseModel
	UpdateTransitGatewayExecute(r ApiUpdateTransitGatewayRequest) (*BnsTgwV1ApiUpdateTransitGatewayModelCreateTgwResponseModel, *http.Response, error)
}

// TgwsAPIService TgwsAPI service
type TgwsAPIService service

type ApiCreateTransitGatewayRequest struct {
	ctx                   context.Context
	ApiService            TgwsAPI
	xAuthToken            *string
	createTgwRequestModel *CreateTgwRequestModel
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiCreateTransitGatewayRequest) XAuthToken(xAuthToken string) ApiCreateTransitGatewayRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiCreateTransitGatewayRequest) CreateTgwRequestModel(createTgwRequestModel CreateTgwRequestModel) ApiCreateTransitGatewayRequest {
	r.createTgwRequestModel = &createTgwRequestModel
	return r
}

func (r ApiCreateTransitGatewayRequest) Execute() (*BnsTgwV1ApiCreateTransitGatewayModelCreateTgwResponseModel, *http.Response, error) {
	return r.ApiService.CreateTransitGatewayExecute(r)
}

/*
CreateTransitGateway Create transit gateway

Transit Gateway를 생성합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateTransitGatewayRequest
*/
func (a *TgwsAPIService) CreateTransitGateway(ctx context.Context) ApiCreateTransitGatewayRequest {
	return ApiCreateTransitGatewayRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BnsTgwV1ApiCreateTransitGatewayModelCreateTgwResponseModel
func (a *TgwsAPIService) CreateTransitGatewayExecute(r ApiCreateTransitGatewayRequest) (*BnsTgwV1ApiCreateTransitGatewayModelCreateTgwResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsTgwV1ApiCreateTransitGatewayModelCreateTgwResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TgwsAPIService.CreateTransitGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/tgws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.createTgwRequestModel == nil {
		return localVarReturnValue, nil, reportError("createTgwRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.createTgwRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteTransitGatewayRequest struct {
	ctx        context.Context
	ApiService TgwsAPI
	tgwId      string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiDeleteTransitGatewayRequest) XAuthToken(xAuthToken string) ApiDeleteTransitGatewayRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiDeleteTransitGatewayRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTransitGatewayExecute(r)
}

/*
DeleteTransitGateway Delete transit gateway

지정한 Transit Gateway를 삭제합니다.<br/>
Transit Gateway 삭제 시 연결된 모든 Attachment, 라우팅 테이블, Association 등의 종속 리소스가 함께 해제되며, 삭제된 Transit Gateway는 복구할 수 없습니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tgwId 삭제할 Transit Gateway ID
	@return ApiDeleteTransitGatewayRequest
*/
func (a *TgwsAPIService) DeleteTransitGateway(ctx context.Context, tgwId string) ApiDeleteTransitGatewayRequest {
	return ApiDeleteTransitGatewayRequest{
		ApiService: a,
		ctx:        ctx,
		tgwId:      tgwId,
	}
}

// Execute executes the request
func (a *TgwsAPIService) DeleteTransitGatewayExecute(r ApiDeleteTransitGatewayRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TgwsAPIService.DeleteTransitGateway")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/tgws/{tgw_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tgw_id"+"}", url.PathEscape(parameterValueToString(r.tgwId, "tgwId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetTransitGatewayRequest struct {
	ctx        context.Context
	ApiService TgwsAPI
	tgwId      string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiGetTransitGatewayRequest) XAuthToken(xAuthToken string) ApiGetTransitGatewayRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiGetTransitGatewayRequest) Execute() (*GetTgwResponseModel, *http.Response, error) {
	return r.ApiService.GetTransitGatewayExecute(r)
}

/*
GetTransitGateway Get transit gateway

Transit Gateway 상세 정보를 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tgwId 조회할 Transit Gateway ID
	@return ApiGetTransitGatewayRequest
*/
func (a *TgwsAPIService) GetTransitGateway(ctx context.Context, tgwId string) ApiGetTransitGatewayRequest {
	return ApiGetTransitGatewayRequest{
		ApiService: a,
		ctx:        ctx,
		tgwId:      tgwId,
	}
}

// Execute executes the request
//
//	@return GetTgwResponseModel
func (a *TgwsAPIService) GetTransitGatewayExecute(r ApiGetTransitGatewayRequest) (*GetTgwResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetTgwResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TgwsAPIService.GetTransitGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/tgws/{tgw_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tgw_id"+"}", url.PathEscape(parameterValueToString(r.tgwId, "tgwId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTgwSharedProjectsRequest struct {
	ctx        context.Context
	ApiService TgwsAPI
	tgwId      string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiListTgwSharedProjectsRequest) XAuthToken(xAuthToken string) ApiListTgwSharedProjectsRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiListTgwSharedProjectsRequest) Execute() (*GetTgwProjectsResponseModel, *http.Response, error) {
	return r.ApiService.ListTgwSharedProjectsExecute(r)
}

/*
ListTgwSharedProjects List TGW shared projects

지정한 Transit Gateway ID에 대해 공유된 프로젝트 목록을 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tgwId 조회할 Transit Gateway ID
	@return ApiListTgwSharedProjectsRequest
*/
func (a *TgwsAPIService) ListTgwSharedProjects(ctx context.Context, tgwId string) ApiListTgwSharedProjectsRequest {
	return ApiListTgwSharedProjectsRequest{
		ApiService: a,
		ctx:        ctx,
		tgwId:      tgwId,
	}
}

// Execute executes the request
//
//	@return GetTgwProjectsResponseModel
func (a *TgwsAPIService) ListTgwSharedProjectsExecute(r ApiListTgwSharedProjectsRequest) (*GetTgwProjectsResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetTgwProjectsResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TgwsAPIService.ListTgwSharedProjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/tgws/{tgw_id}/projects"
	localVarPath = strings.Replace(localVarPath, "{"+"tgw_id"+"}", url.PathEscape(parameterValueToString(r.tgwId, "tgwId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransitGatewaysRequest struct {
	ctx                context.Context
	ApiService         TgwsAPI
	xAuthToken         *string
	id                 *string
	name               *string
	region             *Region
	isShared           *bool
	provisioningStatus *ProvisioningStatus
	createdAt          *string
	updatedAt          *string
	offset             *int32
	limit              *int32
	sortKeys           *string
	sortDirs           *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiListTransitGatewaysRequest) XAuthToken(xAuthToken string) ApiListTransitGatewaysRequest {
	r.xAuthToken = &xAuthToken
	return r
}

// Transit Gateway ID
func (r ApiListTransitGatewaysRequest) Id(id string) ApiListTransitGatewaysRequest {
	r.id = &id
	return r
}

// Transit Gateway 이름
func (r ApiListTransitGatewaysRequest) Name(name string) ApiListTransitGatewaysRequest {
	r.name = &name
	return r
}

// Transit Gateway가 위치한 리전 (예: &#x60;kr-central-2&#x60;)
func (r ApiListTransitGatewaysRequest) Region(region Region) ApiListTransitGatewaysRequest {
	r.region = &region
	return r
}

// 공유된 Transit Gateway 여부 (예: &#x60;true&#x60;)
func (r ApiListTransitGatewaysRequest) IsShared(isShared bool) ApiListTransitGatewaysRequest {
	r.isShared = &isShared
	return r
}

// Transit Gateway 프로비저닝 상태
func (r ApiListTransitGatewaysRequest) ProvisioningStatus(provisioningStatus ProvisioningStatus) ApiListTransitGatewaysRequest {
	r.provisioningStatus = &provisioningStatus
	return r
}

// 리소스가 생성된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListTransitGatewaysRequest) CreatedAt(createdAt string) ApiListTransitGatewaysRequest {
	r.createdAt = &createdAt
	return r
}

// 리소스가 마지막으로 수정된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListTransitGatewaysRequest) UpdatedAt(updatedAt string) ApiListTransitGatewaysRequest {
	r.updatedAt = &updatedAt
	return r
}

// 조회 시작 위치
func (r ApiListTransitGatewaysRequest) Offset(offset int32) ApiListTransitGatewaysRequest {
	r.offset = &offset
	return r
}

// 페이지당 최대 반환 항목 수
func (r ApiListTransitGatewaysRequest) Limit(limit int32) ApiListTransitGatewaysRequest {
	r.limit = &limit
	return r
}

// 정렬할 필드
func (r ApiListTransitGatewaysRequest) SortKeys(sortKeys string) ApiListTransitGatewaysRequest {
	r.sortKeys = &sortKeys
	return r
}

// 정렬 방향 (&#x60;asc&#x60;, &#x60;desc&#x60;)
func (r ApiListTransitGatewaysRequest) SortDirs(sortDirs string) ApiListTransitGatewaysRequest {
	r.sortDirs = &sortDirs
	return r
}

func (r ApiListTransitGatewaysRequest) Execute() (*GetTgwsResponseModel, *http.Response, error) {
	return r.ApiService.ListTransitGatewaysExecute(r)
}

/*
ListTransitGateways List transit gateways

Transit Gateway 목록을 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListTransitGatewaysRequest
*/
func (a *TgwsAPIService) ListTransitGateways(ctx context.Context) ApiListTransitGatewaysRequest {
	return ApiListTransitGatewaysRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return GetTgwsResponseModel
func (a *TgwsAPIService) ListTransitGatewaysExecute(r ApiListTransitGatewaysRequest) (*GetTgwsResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetTgwsResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TgwsAPIService.ListTransitGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/tgws"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.region != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "region", r.region, "form", "")
	}
	if r.isShared != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_shared", r.isShared, "form", "")
	}
	if r.provisioningStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provisioning_status", r.provisioningStatus, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.sortKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_keys", r.sortKeys, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortKeys = &defaultValue
	}
	if r.sortDirs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dirs", r.sortDirs, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortDirs = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShareTransitGatewayRequest struct {
	ctx             context.Context
	ApiService      TgwsAPI
	tgwId           string
	targetProjectId string
	xAuthToken      *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiShareTransitGatewayRequest) XAuthToken(xAuthToken string) ApiShareTransitGatewayRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiShareTransitGatewayRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ShareTransitGatewayExecute(r)
}

/*
ShareTransitGateway Share transit gateway

지정한 Transit Gateway를 다른 프로젝트에 공유합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tgwId 공유할 Transit Gateway ID
	@param targetProjectId 공유 대상 프로젝트 ID
	@return ApiShareTransitGatewayRequest
*/
func (a *TgwsAPIService) ShareTransitGateway(ctx context.Context, tgwId string, targetProjectId string) ApiShareTransitGatewayRequest {
	return ApiShareTransitGatewayRequest{
		ApiService:      a,
		ctx:             ctx,
		tgwId:           tgwId,
		targetProjectId: targetProjectId,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *TgwsAPIService) ShareTransitGatewayExecute(r ApiShareTransitGatewayRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TgwsAPIService.ShareTransitGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/tgws/{tgw_id}/projects/{target_project_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tgw_id"+"}", url.PathEscape(parameterValueToString(r.tgwId, "tgwId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_project_id"+"}", url.PathEscape(parameterValueToString(r.targetProjectId, "targetProjectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnshareTransitGatewayRequest struct {
	ctx             context.Context
	ApiService      TgwsAPI
	tgwId           string
	targetProjectId string
	xAuthToken      *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUnshareTransitGatewayRequest) XAuthToken(xAuthToken string) ApiUnshareTransitGatewayRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUnshareTransitGatewayRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnshareTransitGatewayExecute(r)
}

/*
UnshareTransitGateway Unshare transit gateway

지정한 Transit Gateway의 공유를 해제하여, 해당 프로젝트에서 사용하지 않도록 합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tgwId 공유 해제할 Transit Gateway ID
	@param targetProjectId 공유 해제 대상 프로젝트 ID
	@return ApiUnshareTransitGatewayRequest
*/
func (a *TgwsAPIService) UnshareTransitGateway(ctx context.Context, tgwId string, targetProjectId string) ApiUnshareTransitGatewayRequest {
	return ApiUnshareTransitGatewayRequest{
		ApiService:      a,
		ctx:             ctx,
		tgwId:           tgwId,
		targetProjectId: targetProjectId,
	}
}

// Execute executes the request
func (a *TgwsAPIService) UnshareTransitGatewayExecute(r ApiUnshareTransitGatewayRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TgwsAPIService.UnshareTransitGateway")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/tgws/{tgw_id}/projects/{target_project_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tgw_id"+"}", url.PathEscape(parameterValueToString(r.tgwId, "tgwId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"target_project_id"+"}", url.PathEscape(parameterValueToString(r.targetProjectId, "targetProjectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateTransitGatewayRequest struct {
	ctx                   context.Context
	ApiService            TgwsAPI
	tgwId                 string
	xAuthToken            *string
	updateTgwRequestModel *UpdateTgwRequestModel
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUpdateTransitGatewayRequest) XAuthToken(xAuthToken string) ApiUpdateTransitGatewayRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUpdateTransitGatewayRequest) UpdateTgwRequestModel(updateTgwRequestModel UpdateTgwRequestModel) ApiUpdateTransitGatewayRequest {
	r.updateTgwRequestModel = &updateTgwRequestModel
	return r
}

func (r ApiUpdateTransitGatewayRequest) Execute() (*BnsTgwV1ApiUpdateTransitGatewayModelCreateTgwResponseModel, *http.Response, error) {
	return r.ApiService.UpdateTransitGatewayExecute(r)
}

/*
UpdateTransitGateway Update transit gateway

Transit Gateway 설정을 수정합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tgwId 수정할 Transit Gateway ID
	@return ApiUpdateTransitGatewayRequest
*/
func (a *TgwsAPIService) UpdateTransitGateway(ctx context.Context, tgwId string) ApiUpdateTransitGatewayRequest {
	return ApiUpdateTransitGatewayRequest{
		ApiService: a,
		ctx:        ctx,
		tgwId:      tgwId,
	}
}

// Execute executes the request
//
//	@return BnsTgwV1ApiUpdateTransitGatewayModelCreateTgwResponseModel
func (a *TgwsAPIService) UpdateTransitGatewayExecute(r ApiUpdateTransitGatewayRequest) (*BnsTgwV1ApiUpdateTransitGatewayModelCreateTgwResponseModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BnsTgwV1ApiUpdateTransitGatewayModelCreateTgwResponseModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TgwsAPIService.UpdateTransitGateway")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/tgws/{tgw_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"tgw_id"+"}", url.PathEscape(parameterValueToString(r.tgwId, "tgwId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.updateTgwRequestModel == nil {
		return localVarReturnValue, nil, reportError("updateTgwRequestModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.updateTgwRequestModel
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
