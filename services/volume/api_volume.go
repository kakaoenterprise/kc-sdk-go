/*
Beyond Compute Service(BCS) Volume API

Beyond Compute Service Volume API

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package volume

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type VolumeAPI interface {

	/*
		CreateImage Create image

		특정 볼륨을 기반으로 이미지(템플릿)를 생성합니다.

	:::info 안내
	- 운영체제가 설치된 루트 볼륨만 이미지로 생성할 수 있습니다. 추가 볼륨을 백업할 경우, [스냅샷](https://docs.kakaocloud.com/openapi/bcs/create-snapshot) 기능을 이용하시기 바랍니다.
	- 생성한 VM 인스턴스로부터 이미지 생성을 통해 내 이미지를 생성할 경우, 연결된 루트 볼륨의 크기에 따라 작업이 실패할 수 있습니다. 내 이미지를 생성할 때 해당 인스턴스에 연결된 대상 볼륨의 크기는 1 TB 이하를 권장합니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param volumeId 볼륨의 고유 ID
		@return ApiCreateImageRequest
	*/
	CreateImage(ctx context.Context, volumeId string) ApiCreateImageRequest

	// CreateImageExecute executes the request
	//  @return ResponseVolumeImageModel
	CreateImageExecute(r ApiCreateImageRequest) (*ResponseVolumeImageModel, *http.Response, error)

	/*
		CreateSnapshot Create snapshot

		볼륨의 현재 상태를 저장하는 신규 스냅샷을 생성합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param volumeId 볼륨의 고유 ID
		@return ApiCreateSnapshotRequest
	*/
	CreateSnapshot(ctx context.Context, volumeId string) ApiCreateSnapshotRequest

	// CreateSnapshotExecute executes the request
	//  @return ResponseCreateVolumeSnapshotModel
	CreateSnapshotExecute(r ApiCreateSnapshotRequest) (*ResponseCreateVolumeSnapshotModel, *http.Response, error)

	/*
		CreateVolume Create volume

		신규 볼륨을 생성합니다. 새로운 스토리지가 필요한 경우 볼륨을 생성하여 인스턴스에 연결할 수 있습니다. <br/>
	생성된 볼륨은 상태가 `available`로 변경되면 사용할 수 있으며, 필요 시 인스턴스에 연결(attach)하여 활용할 수 있습니다. 볼륨을 인스턴스에 연결하기 위해서는 [Attach volume API](https://docs.kakaocloud.com/openapi/bcs/attach-volume)를 호출해 주세요.

	:::info 안내
	- 볼륨 크기는 최소 허용 용량 이상이어야 합니다. 자세한 정보는 [볼륨 크기 제한](https://docs.kakaocloud.com/service/bcs/vm/vm-main#volume-size-limit)을 참고해 주세요.
	- 볼륨 생성 시, 쿼터 내(프로젝트당 1,000개)에서 생성할 수 있습니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateVolumeRequest
	*/
	CreateVolume(ctx context.Context) ApiCreateVolumeRequest

	// CreateVolumeExecute executes the request
	//  @return BcsVolumeV1ApiCreateVolumeModelResponseVolumeModel
	CreateVolumeExecute(r ApiCreateVolumeRequest) (*BcsVolumeV1ApiCreateVolumeModelResponseVolumeModel, *http.Response, error)

	/*
		DeleteVolume Delete volume

		볼륨을 삭제합니다.

	:::info 안내
	`In-use`(사용 중)인 상태의 볼륨 또는 `Deleting`(삭제 중) 상태의 볼륨은 삭제할 수 없습니다. 볼륨 상태 정보는 [List instance volumes API](https://docs.kakaocloud.com/openapi/bcs/list-volumes)를 통해 확인할 수 있습니다.
	:::

	:::caution 주의
	삭제된 볼륨은 복구할 수 없습니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param volumeId 볼륨의 고유 ID
		@return ApiDeleteVolumeRequest
	*/
	DeleteVolume(ctx context.Context, volumeId string) ApiDeleteVolumeRequest

	// DeleteVolumeExecute executes the request
	//  @return interface{}
	DeleteVolumeExecute(r ApiDeleteVolumeRequest) (interface{}, *http.Response, error)

	/*
		ExtendVolume Extend volume

		볼륨의 크기를 확장합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param volumeId 볼륨의 고유 ID
		@return ApiExtendVolumeRequest
	*/
	ExtendVolume(ctx context.Context, volumeId string) ApiExtendVolumeRequest

	// ExtendVolumeExecute executes the request
	//  @return interface{}
	ExtendVolumeExecute(r ApiExtendVolumeRequest) (interface{}, *http.Response, error)

	/*
		GetVolume Get volume

		지정한 볼륨의 상세 정보를 조회합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param volumeId 볼륨의 고유 ID
		@return ApiGetVolumeRequest
	*/
	GetVolume(ctx context.Context, volumeId string) ApiGetVolumeRequest

	// GetVolumeExecute executes the request
	//  @return BcsVolumeV1ApiGetVolumeModelResponseVolumeModel
	GetVolumeExecute(r ApiGetVolumeRequest) (*BcsVolumeV1ApiGetVolumeModelResponseVolumeModel, *http.Response, error)

	/*
		ListVolumeTypes List volume types

		볼륨 유형별 목록과 각 볼륨 유형의 세부 정보를 조회합니다. <br/>볼륨 유형은 디스크 스토리지 유형을 구분하는 요소로, 각 유형에 따라 성능과 용도가 다를 수 있습니다. 자세한 정보는 [볼륨](https://docs.kakaocloud.com/service/bcs/vm/vm-main#volume)을 참고해 주세요.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListVolumeTypesRequest
	*/
	ListVolumeTypes(ctx context.Context) ApiListVolumeTypesRequest

	// ListVolumeTypesExecute executes the request
	//  @return VolumeTypeListModel
	ListVolumeTypesExecute(r ApiListVolumeTypesRequest) (*VolumeTypeListModel, *http.Response, error)

	/*
		ListVolumes List volumes

		사용자가 생성한 볼륨 목록과 볼륨의 상세 정보를 조회합니다.

	:::info 안내
	특정 프로젝트에 속한 볼륨에 대해서만 조회할 수 있습니다.
	:::

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListVolumesRequest
	*/
	ListVolumes(ctx context.Context) ApiListVolumesRequest

	// ListVolumesExecute executes the request
	//  @return VolumeListModel
	ListVolumesExecute(r ApiListVolumesRequest) (*VolumeListModel, *http.Response, error)

	/*
		UpdateVolume Update volume

		인스턴스에 연결된 특정 볼륨의 정보를 수정합니다.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param volumeId 볼륨의 고유 ID
		@return ApiUpdateVolumeRequest
	*/
	UpdateVolume(ctx context.Context, volumeId string) ApiUpdateVolumeRequest

	// UpdateVolumeExecute executes the request
	//  @return BcsVolumeV1ApiUpdateVolumeModelResponseVolumeModel
	UpdateVolumeExecute(r ApiUpdateVolumeRequest) (*BcsVolumeV1ApiUpdateVolumeModelResponseVolumeModel, *http.Response, error)
}

// VolumeAPIService VolumeAPI service
type VolumeAPIService service

type ApiCreateImageRequest struct {
	ctx             context.Context
	ApiService      VolumeAPI
	volumeId        string
	xAuthToken      *string
	bodyCreateImage *BodyCreateImage
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiCreateImageRequest) XAuthToken(xAuthToken string) ApiCreateImageRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiCreateImageRequest) BodyCreateImage(bodyCreateImage BodyCreateImage) ApiCreateImageRequest {
	r.bodyCreateImage = &bodyCreateImage
	return r
}

func (r ApiCreateImageRequest) Execute() (*ResponseVolumeImageModel, *http.Response, error) {
	return r.ApiService.CreateImageExecute(r)
}

/*
CreateImage Create image

특정 볼륨을 기반으로 이미지(템플릿)를 생성합니다.

:::info 안내
- 운영체제가 설치된 루트 볼륨만 이미지로 생성할 수 있습니다. 추가 볼륨을 백업할 경우, [스냅샷](https://docs.kakaocloud.com/openapi/bcs/create-snapshot) 기능을 이용하시기 바랍니다.
- 생성한 VM 인스턴스로부터 이미지 생성을 통해 내 이미지를 생성할 경우, 연결된 루트 볼륨의 크기에 따라 작업이 실패할 수 있습니다. 내 이미지를 생성할 때 해당 인스턴스에 연결된 대상 볼륨의 크기는 1 TB 이하를 권장합니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param volumeId 볼륨의 고유 ID
	@return ApiCreateImageRequest
*/
func (a *VolumeAPIService) CreateImage(ctx context.Context, volumeId string) ApiCreateImageRequest {
	return ApiCreateImageRequest{
		ApiService: a,
		ctx:        ctx,
		volumeId:   volumeId,
	}
}

// Execute executes the request
//
//	@return ResponseVolumeImageModel
func (a *VolumeAPIService) CreateImageExecute(r ApiCreateImageRequest) (*ResponseVolumeImageModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseVolumeImageModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.CreateImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/volumes/{volume_id}/image"
	localVarPath = strings.Replace(localVarPath, "{"+"volume_id"+"}", url.PathEscape(parameterValueToString(r.volumeId, "volumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyCreateImage == nil {
		return localVarReturnValue, nil, reportError("bodyCreateImage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyCreateImage
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSnapshotRequest struct {
	ctx                context.Context
	ApiService         VolumeAPI
	volumeId           string
	xAuthToken         *string
	bodyCreateSnapshot *BodyCreateSnapshot
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiCreateSnapshotRequest) XAuthToken(xAuthToken string) ApiCreateSnapshotRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiCreateSnapshotRequest) BodyCreateSnapshot(bodyCreateSnapshot BodyCreateSnapshot) ApiCreateSnapshotRequest {
	r.bodyCreateSnapshot = &bodyCreateSnapshot
	return r
}

func (r ApiCreateSnapshotRequest) Execute() (*ResponseCreateVolumeSnapshotModel, *http.Response, error) {
	return r.ApiService.CreateSnapshotExecute(r)
}

/*
CreateSnapshot Create snapshot

볼륨의 현재 상태를 저장하는 신규 스냅샷을 생성합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param volumeId 볼륨의 고유 ID
	@return ApiCreateSnapshotRequest
*/
func (a *VolumeAPIService) CreateSnapshot(ctx context.Context, volumeId string) ApiCreateSnapshotRequest {
	return ApiCreateSnapshotRequest{
		ApiService: a,
		ctx:        ctx,
		volumeId:   volumeId,
	}
}

// Execute executes the request
//
//	@return ResponseCreateVolumeSnapshotModel
func (a *VolumeAPIService) CreateSnapshotExecute(r ApiCreateSnapshotRequest) (*ResponseCreateVolumeSnapshotModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ResponseCreateVolumeSnapshotModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.CreateSnapshot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/volumes/{volume_id}/snapshots"
	localVarPath = strings.Replace(localVarPath, "{"+"volume_id"+"}", url.PathEscape(parameterValueToString(r.volumeId, "volumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyCreateSnapshot == nil {
		return localVarReturnValue, nil, reportError("bodyCreateSnapshot is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyCreateSnapshot
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateVolumeRequest struct {
	ctx              context.Context
	ApiService       VolumeAPI
	xAuthToken       *string
	bodyCreateVolume *BodyCreateVolume
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiCreateVolumeRequest) XAuthToken(xAuthToken string) ApiCreateVolumeRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiCreateVolumeRequest) BodyCreateVolume(bodyCreateVolume BodyCreateVolume) ApiCreateVolumeRequest {
	r.bodyCreateVolume = &bodyCreateVolume
	return r
}

func (r ApiCreateVolumeRequest) Execute() (*BcsVolumeV1ApiCreateVolumeModelResponseVolumeModel, *http.Response, error) {
	return r.ApiService.CreateVolumeExecute(r)
}

/*
CreateVolume Create volume

신규 볼륨을 생성합니다. 새로운 스토리지가 필요한 경우 볼륨을 생성하여 인스턴스에 연결할 수 있습니다. <br/>
생성된 볼륨은 상태가 `available`로 변경되면 사용할 수 있으며, 필요 시 인스턴스에 연결(attach)하여 활용할 수 있습니다. 볼륨을 인스턴스에 연결하기 위해서는 [Attach volume API](https://docs.kakaocloud.com/openapi/bcs/attach-volume)를 호출해 주세요.

:::info 안내
- 볼륨 크기는 최소 허용 용량 이상이어야 합니다. 자세한 정보는 [볼륨 크기 제한](https://docs.kakaocloud.com/service/bcs/vm/vm-main#volume-size-limit)을 참고해 주세요.
- 볼륨 생성 시, 쿼터 내(프로젝트당 1,000개)에서 생성할 수 있습니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateVolumeRequest
*/
func (a *VolumeAPIService) CreateVolume(ctx context.Context) ApiCreateVolumeRequest {
	return ApiCreateVolumeRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BcsVolumeV1ApiCreateVolumeModelResponseVolumeModel
func (a *VolumeAPIService) CreateVolumeExecute(r ApiCreateVolumeRequest) (*BcsVolumeV1ApiCreateVolumeModelResponseVolumeModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BcsVolumeV1ApiCreateVolumeModelResponseVolumeModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.CreateVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/volumes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyCreateVolume == nil {
		return localVarReturnValue, nil, reportError("bodyCreateVolume is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyCreateVolume
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVolumeRequest struct {
	ctx        context.Context
	ApiService VolumeAPI
	volumeId   string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiDeleteVolumeRequest) XAuthToken(xAuthToken string) ApiDeleteVolumeRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiDeleteVolumeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DeleteVolumeExecute(r)
}

/*
DeleteVolume Delete volume

볼륨을 삭제합니다.

:::info 안내
`In-use`(사용 중)인 상태의 볼륨 또는 `Deleting`(삭제 중) 상태의 볼륨은 삭제할 수 없습니다. 볼륨 상태 정보는 [List instance volumes API](https://docs.kakaocloud.com/openapi/bcs/list-volumes)를 통해 확인할 수 있습니다.
:::

:::caution 주의
삭제된 볼륨은 복구할 수 없습니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param volumeId 볼륨의 고유 ID
	@return ApiDeleteVolumeRequest
*/
func (a *VolumeAPIService) DeleteVolume(ctx context.Context, volumeId string) ApiDeleteVolumeRequest {
	return ApiDeleteVolumeRequest{
		ApiService: a,
		ctx:        ctx,
		volumeId:   volumeId,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *VolumeAPIService) DeleteVolumeExecute(r ApiDeleteVolumeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.DeleteVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/volumes/{volume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"volume_id"+"}", url.PathEscape(parameterValueToString(r.volumeId, "volumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtendVolumeRequest struct {
	ctx              context.Context
	ApiService       VolumeAPI
	volumeId         string
	xAuthToken       *string
	bodyExtendVolume *BodyExtendVolume
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiExtendVolumeRequest) XAuthToken(xAuthToken string) ApiExtendVolumeRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiExtendVolumeRequest) BodyExtendVolume(bodyExtendVolume BodyExtendVolume) ApiExtendVolumeRequest {
	r.bodyExtendVolume = &bodyExtendVolume
	return r
}

func (r ApiExtendVolumeRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ExtendVolumeExecute(r)
}

/*
ExtendVolume Extend volume

볼륨의 크기를 확장합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param volumeId 볼륨의 고유 ID
	@return ApiExtendVolumeRequest
*/
func (a *VolumeAPIService) ExtendVolume(ctx context.Context, volumeId string) ApiExtendVolumeRequest {
	return ApiExtendVolumeRequest{
		ApiService: a,
		ctx:        ctx,
		volumeId:   volumeId,
	}
}

// Execute executes the request
//
//	@return interface{}
func (a *VolumeAPIService) ExtendVolumeExecute(r ApiExtendVolumeRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.ExtendVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/volumes/{volume_id}/size"
	localVarPath = strings.Replace(localVarPath, "{"+"volume_id"+"}", url.PathEscape(parameterValueToString(r.volumeId, "volumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyExtendVolume == nil {
		return localVarReturnValue, nil, reportError("bodyExtendVolume is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyExtendVolume
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVolumeRequest struct {
	ctx        context.Context
	ApiService VolumeAPI
	volumeId   string
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiGetVolumeRequest) XAuthToken(xAuthToken string) ApiGetVolumeRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiGetVolumeRequest) Execute() (*BcsVolumeV1ApiGetVolumeModelResponseVolumeModel, *http.Response, error) {
	return r.ApiService.GetVolumeExecute(r)
}

/*
GetVolume Get volume

지정한 볼륨의 상세 정보를 조회합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param volumeId 볼륨의 고유 ID
	@return ApiGetVolumeRequest
*/
func (a *VolumeAPIService) GetVolume(ctx context.Context, volumeId string) ApiGetVolumeRequest {
	return ApiGetVolumeRequest{
		ApiService: a,
		ctx:        ctx,
		volumeId:   volumeId,
	}
}

// Execute executes the request
//
//	@return BcsVolumeV1ApiGetVolumeModelResponseVolumeModel
func (a *VolumeAPIService) GetVolumeExecute(r ApiGetVolumeRequest) (*BcsVolumeV1ApiGetVolumeModelResponseVolumeModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BcsVolumeV1ApiGetVolumeModelResponseVolumeModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.GetVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/volumes/{volume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"volume_id"+"}", url.PathEscape(parameterValueToString(r.volumeId, "volumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVolumeTypesRequest struct {
	ctx        context.Context
	ApiService VolumeAPI
	xAuthToken *string
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiListVolumeTypesRequest) XAuthToken(xAuthToken string) ApiListVolumeTypesRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiListVolumeTypesRequest) Execute() (*VolumeTypeListModel, *http.Response, error) {
	return r.ApiService.ListVolumeTypesExecute(r)
}

/*
ListVolumeTypes List volume types

볼륨 유형별 목록과 각 볼륨 유형의 세부 정보를 조회합니다. <br/>볼륨 유형은 디스크 스토리지 유형을 구분하는 요소로, 각 유형에 따라 성능과 용도가 다를 수 있습니다. 자세한 정보는 [볼륨](https://docs.kakaocloud.com/service/bcs/vm/vm-main#volume)을 참고해 주세요.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListVolumeTypesRequest
*/
func (a *VolumeAPIService) ListVolumeTypes(ctx context.Context) ApiListVolumeTypesRequest {
	return ApiListVolumeTypesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VolumeTypeListModel
func (a *VolumeAPIService) ListVolumeTypesExecute(r ApiListVolumeTypesRequest) (*VolumeTypeListModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VolumeTypeListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.ListVolumeTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/volumes/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListVolumesRequest struct {
	ctx              context.Context
	ApiService       VolumeAPI
	xAuthToken       *string
	id               *string
	name             *string
	status           *string
	instanceId       *string
	mountPoint       *string
	type_            *string
	size             *int32
	availabilityZone *AvailabilityZone
	instanceName     *string
	volumeType       *string
	attachStatus     *string
	isBootable       *bool
	isEncrypted      *bool
	isRoot           *bool
	createdAt        *string
	updatedAt        *string
	sortKeys         *string
	sortDirs         *string
	limit            *int32
	offset           *int32
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiListVolumesRequest) XAuthToken(xAuthToken string) ApiListVolumesRequest {
	r.xAuthToken = &xAuthToken
	return r
}

// 조회할 볼륨 ID
func (r ApiListVolumesRequest) Id(id string) ApiListVolumesRequest {
	r.id = &id
	return r
}

// 조회할 볼륨 이름
func (r ApiListVolumesRequest) Name(name string) ApiListVolumesRequest {
	r.name = &name
	return r
}

// 조회할 볼륨 상태  &lt;br/&gt; - [볼륨 상태값](https://docs.kakaocloud.com/service/bcs/vm/vm-main#volume-states)
func (r ApiListVolumesRequest) Status(status string) ApiListVolumesRequest {
	r.status = &status
	return r
}

// 인스턴스의 고유 ID
func (r ApiListVolumesRequest) InstanceId(instanceId string) ApiListVolumesRequest {
	r.instanceId = &instanceId
	return r
}

// 볼륨이 인스턴스에 마운트된 경로 &lt;br/&gt; - 예시: &#x60;/dev/vdb&#x60;
func (r ApiListVolumesRequest) MountPoint(mountPoint string) ApiListVolumesRequest {
	r.mountPoint = &mountPoint
	return r
}

// 볼륨 저장소 유형
func (r ApiListVolumesRequest) Type_(type_ string) ApiListVolumesRequest {
	r.type_ = &type_
	return r
}

// 조회할 볼륨 크기 (GB 단위)
func (r ApiListVolumesRequest) Size(size int32) ApiListVolumesRequest {
	r.size = &size
	return r
}

// 볼륨이 생성된 가용 영역&lt;br/&gt; - &#x60;kr-central-2-a&#x60;: kr-central-2-a 가용 영역 &lt;br/&gt; - &#x60;kr-central-2-b&#x60;: kr-central-2-b 가용 영역 &lt;br/&gt; - &#x60;kr-central-2-c&#x60;: kr-central-2-c 가용 영역
func (r ApiListVolumesRequest) AvailabilityZone(availabilityZone AvailabilityZone) ApiListVolumesRequest {
	r.availabilityZone = &availabilityZone
	return r
}

// 연결된 인스턴스 이름
func (r ApiListVolumesRequest) InstanceName(instanceName string) ApiListVolumesRequest {
	r.instanceName = &instanceName
	return r
}

// 볼륨 유형 이름
func (r ApiListVolumesRequest) VolumeType(volumeType string) ApiListVolumesRequest {
	r.volumeType = &volumeType
	return r
}

// 볼륨 연결 상태 &lt;br/&gt; - 예시: &#x60;attached&#x60;, &#x60;detached&#x60;
func (r ApiListVolumesRequest) AttachStatus(attachStatus string) ApiListVolumesRequest {
	r.attachStatus = &attachStatus
	return r
}

// 부팅 가능 여부
func (r ApiListVolumesRequest) IsBootable(isBootable bool) ApiListVolumesRequest {
	r.isBootable = &isBootable
	return r
}

// 암호화 여부
func (r ApiListVolumesRequest) IsEncrypted(isEncrypted bool) ApiListVolumesRequest {
	r.isEncrypted = &isEncrypted
	return r
}

// 볼륨이 루트 디스크인지 여부
func (r ApiListVolumesRequest) IsRoot(isRoot bool) ApiListVolumesRequest {
	r.isRoot = &isRoot
	return r
}

// 리소스가 생성된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListVolumesRequest) CreatedAt(createdAt string) ApiListVolumesRequest {
	r.createdAt = &createdAt
	return r
}

// 리소스가 마지막으로 수정된 시간 &lt;br/&gt; - ISO_8601 형식  &lt;br/&gt; - UTC 기준
func (r ApiListVolumesRequest) UpdatedAt(updatedAt string) ApiListVolumesRequest {
	r.updatedAt = &updatedAt
	return r
}

// 정렬할 필드를 콤마(,)로 구분
func (r ApiListVolumesRequest) SortKeys(sortKeys string) ApiListVolumesRequest {
	r.sortKeys = &sortKeys
	return r
}

// 정렬 방향 (&#x60;asc&#x60;, &#x60;desc&#x60;)
func (r ApiListVolumesRequest) SortDirs(sortDirs string) ApiListVolumesRequest {
	r.sortDirs = &sortDirs
	return r
}

// 페이지당 최대 반환 항목 수
func (r ApiListVolumesRequest) Limit(limit int32) ApiListVolumesRequest {
	r.limit = &limit
	return r
}

// 조회 시작 위치
func (r ApiListVolumesRequest) Offset(offset int32) ApiListVolumesRequest {
	r.offset = &offset
	return r
}

func (r ApiListVolumesRequest) Execute() (*VolumeListModel, *http.Response, error) {
	return r.ApiService.ListVolumesExecute(r)
}

/*
ListVolumes List volumes

사용자가 생성한 볼륨 목록과 볼륨의 상세 정보를 조회합니다.

:::info 안내
특정 프로젝트에 속한 볼륨에 대해서만 조회할 수 있습니다.
:::

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListVolumesRequest
*/
func (a *VolumeAPIService) ListVolumes(ctx context.Context) ApiListVolumesRequest {
	return ApiListVolumesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return VolumeListModel
func (a *VolumeAPIService) ListVolumesExecute(r ApiListVolumesRequest) (*VolumeListModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *VolumeListModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.ListVolumes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/volumes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.mountPoint != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mount_point", r.mountPoint, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "form", "")
	}
	if r.availabilityZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "availability_zone", r.availabilityZone, "form", "")
	}
	if r.instanceName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_name", r.instanceName, "form", "")
	}
	if r.volumeType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "volume_type", r.volumeType, "form", "")
	}
	if r.attachStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "attach_status", r.attachStatus, "form", "")
	}
	if r.isBootable != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_bootable", r.isBootable, "form", "")
	}
	if r.isEncrypted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_encrypted", r.isEncrypted, "form", "")
	}
	if r.isRoot != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_root", r.isRoot, "form", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	if r.sortKeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_keys", r.sortKeys, "form", "")
	} else {
		var defaultValue string = "created_at"
		r.sortKeys = &defaultValue
	}
	if r.sortDirs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_dirs", r.sortDirs, "form", "")
	} else {
		var defaultValue string = "desc"
		r.sortDirs = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 20
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVolumeRequest struct {
	ctx              context.Context
	ApiService       VolumeAPI
	volumeId         string
	xAuthToken       *string
	bodyUpdateVolume *BodyUpdateVolume
}

// - [API 인증 토큰](https://docs.kakaocloud.com/openapi/start#api-인증-토큰-발급)
func (r ApiUpdateVolumeRequest) XAuthToken(xAuthToken string) ApiUpdateVolumeRequest {
	r.xAuthToken = &xAuthToken
	return r
}

func (r ApiUpdateVolumeRequest) BodyUpdateVolume(bodyUpdateVolume BodyUpdateVolume) ApiUpdateVolumeRequest {
	r.bodyUpdateVolume = &bodyUpdateVolume
	return r
}

func (r ApiUpdateVolumeRequest) Execute() (*BcsVolumeV1ApiUpdateVolumeModelResponseVolumeModel, *http.Response, error) {
	return r.ApiService.UpdateVolumeExecute(r)
}

/*
UpdateVolume Update volume

인스턴스에 연결된 특정 볼륨의 정보를 수정합니다.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param volumeId 볼륨의 고유 ID
	@return ApiUpdateVolumeRequest
*/
func (a *VolumeAPIService) UpdateVolume(ctx context.Context, volumeId string) ApiUpdateVolumeRequest {
	return ApiUpdateVolumeRequest{
		ApiService: a,
		ctx:        ctx,
		volumeId:   volumeId,
	}
}

// Execute executes the request
//
//	@return BcsVolumeV1ApiUpdateVolumeModelResponseVolumeModel
func (a *VolumeAPIService) UpdateVolumeExecute(r ApiUpdateVolumeRequest) (*BcsVolumeV1ApiUpdateVolumeModelResponseVolumeModel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BcsVolumeV1ApiUpdateVolumeModelResponseVolumeModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VolumeAPIService.UpdateVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/volumes/{volume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"volume_id"+"}", url.PathEscape(parameterValueToString(r.volumeId, "volumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xAuthToken == nil {
		return localVarReturnValue, nil, reportError("xAuthToken is required and must be specified")
	}
	if r.bodyUpdateVolume == nil {
		return localVarReturnValue, nil, reportError("bodyUpdateVolume is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "x-auth-token", r.xAuthToken, "simple", "")
	// body params
	localVarPostBody = r.bodyUpdateVolume
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-auth-token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Auth-Token"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v ErrorResponseModel
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
